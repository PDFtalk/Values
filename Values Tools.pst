<?xml version="1.0"?><st-source><!-- Name: Values ToolsNotice: Comment: Values are simple immutable literal objects.Defining and generating Value classes.Not needed in runtime images.How to define a Value:1. define the Value subclass2. write the class method #localSpecification (browse for examples)3. select the new class in the browser and right-click menu "add Value methods..." and execute the proposed code changes4. edit the class method #examplePackageName: Values ToolsParcel: #('Values Tools')Version: 3.0.4.0Date: 1:58:47 PM October 19, 2024 --><time-stamp>From VisualWorksÂ®, 9.4 of 5. Januar 2024 on 19. Oktober 2024 at 13:58:47</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>BindingSpecification</name><environment>Smalltalk</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector comment </inst-vars><class-inst-vars></class-inst-vars><imports>			Refactory.Browser.*			</imports><category></category><attributes><package>Values Tools</package></attributes></class><comment><class-id>BindingSpecification</class-id><body>BindingSpecification describes one constant (slot, instvar) of a Value class.Subclasses exist for different types.Part of a ValueSpecification. Used for source generating.Subclasses must implement the following messages:	accessing		type	source generation		pragmaMessageString		printExpressionWithNewline:		printSelectorInstance Variables:	selector		&lt;Symbol&gt;	the instvar</body></comment><class><name>TypedConstantSpecification</name><environment>Smalltalk</environment><super>BindingSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Tools</package></attributes></class><comment><class-id>TypedConstantSpecification</class-id><body>TypedConstantSpecification specifies a simple constant with a type. Subclasses define mandatory and optional versions</body></comment><class><name>CollectionSpecification</name><environment>Smalltalk</environment><super>BindingSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Tools</package></attributes></class><comment><class-id>CollectionSpecification</class-id><body>CollectionSpecification specifies a collecion constant: Array or Dictionary</body></comment><class><name>ConstantSpecification</name><environment>Smalltalk</environment><super>TypedConstantSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Tools</package></attributes></class><comment><class-id>ConstantSpecification</class-id><body>ConstantSpecification specifies a simple mandatory constant with a type</body></comment><class><name>ArraySpecification</name><environment>Smalltalk</environment><super>CollectionSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Tools</package></attributes></class><comment><class-id>ArraySpecification</class-id><body>ArraySpecification specifies an Array constant</body></comment><class><name>OptionalConstantSpecification</name><environment>Smalltalk</environment><super>TypedConstantSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>default </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Tools</package></attributes></class><comment><class-id>OptionalConstantSpecification</class-id><body>OptionalConstantSpecification specifies a simple optional constant with a type and a default</body></comment><class><name>DictionarySpecification</name><environment>Smalltalk</environment><super>CollectionSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Tools</package></attributes></class><comment><class-id>DictionarySpecification</class-id><body>DictionarySpecification specifies a Dictionary constant</body></comment><class><name>ValueSpecification</name><environment>Smalltalk</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constants </inst-vars><class-inst-vars></class-inst-vars><imports>			Refactory.Browser.*			</imports><category></category><attributes><package>Values Tools</package></attributes></class><comment><class-id>ValueSpecification</class-id><body>ValueSpecification describes the structure of a Value classInstance Variables:	constants	&lt;SequenceableCollection of: BindingSpecification&gt;	the constants (inst vars) of the Value class</body></comment><class><name>ValuemapInspector</name><environment>Tools.Trippy</environment><super>Tools.Trippy.DictionaryInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Tools</package></attributes></class><comment><class-id>Tools.Trippy.ValuemapInspector</class-id><body>Inspector leaving the keys in their proper order</body></comment><methods><class-id>BindingSpecification class</class-id> <category>specification</category><body package="Values Tools">localSpecification	&lt;constant: #selector class: #{Symbol}&gt;	&lt;optional: #comment class: #{String} default: 'String new'&gt;</body></methods><methods><class-id>TypedConstantSpecification class</class-id> <category>specification</category><body package="Values Tools">localSpecification	&lt;constant: #type class: #{LiteralBindingReference}&gt;</body></methods><methods><class-id>OptionalConstantSpecification class</class-id> <category>specification</category><body package="Values Tools">localSpecification	&lt;optional: #default class: #{String} default: 'super default'&gt;</body></methods><methods><class-id>ValueSpecification class</class-id> <category>specification</category><body package="Values Tools">localSpecification	&lt;sequence: #constants&gt;</body></methods><methods><class-id>Tools.ListIconLibrary class</class-id> <category>resources</category><body package="Values Tools">value16x16	"Tools.UIMaskEditor new openOnClass: self andSelector: #value16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2120 2120 2120)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3180 3180 3180)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 36 0 0 10 24 0 0 170 101 64 0 169 149 64 0 6 20 0 0 153 85 64 0 101 85 64 0 5 20 0 0 5 20 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Values Tools">value16x16mask	"Tools.UIMaskEditor new openOnClass: self andSelector: #value16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 96 0 0 3 96 0 0 15 248 0 0 15 248 0 0 3 96 0 0 15 248 0 0 15 248 0 0 3 96 0 0 3 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>class probes</category><body package="Values Tools">generateMethodsForValue	&lt;menuItem: 'add Value methods...'			nameKey: #generateMethodsForValue			enablement: #isValueClassSelected			indication: nil			menu: #(#classMenu )			position: 15.1&gt;	| target |	target := self selectedClass isMeta		ifTrue: [self selectedClass soleInstance]		ifFalse: [self selectedClass].	target generateMethods</body></methods><methods><class-id>BindingSpecification</class-id> <category>source generation</category><body package="Values Tools">accessorExpressionFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 30).	wst		nextPutAll: self name;		nextPutAll: ' ifNil: [';		nextPutAll: (self defaultFor: aTargetClass);		nextPut: $].	^wst contents</body><body package="Values Tools">accessorFor: aTargetClass	| sourceAccessor |	sourceAccessor := self sourceAccessorFor: aTargetClass.	(aTargetClass needs: sourceAccessor) ifFalse: [		^nil].	^AddMethodChange compile: sourceAccessor in: aTargetClass classified: #accessing</body><body package="Values Tools">argumentName	"&lt;String&gt;"	^self name , self typeName</body><body package="Values Tools">argumentOrNilStringWhen: useArgument	"&lt;String&gt;"	useArgument ifFalse: [^nil printString].	^self argumentName</body><body package="Values Tools">capitalizedName	"&lt;String&gt;"	^self name copyReplaceFrom: 1 to: 1 with: (String with: self name first asUppercase)</body><body package="Values Tools">exampleParameterStringFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 30).	wst		nextPutAll: self setterName;		space;		nextPutAll: (self exampleStringFor: aTargetClass).	^wst contents</body><body package="Values Tools">exampleStringFor: aTargetClass	"&lt;String&gt;"	^self type value literalExample asSourceFor: aTargetClass</body><body package="Values Tools">initializeExpressionFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPutAll: self name;		nextPutAll: ' := ';		nextPutAll: self argumentName.	^wst contents</body><body package="Values Tools">parameterString	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 30).	wst		nextPutAll: self setterName;		space;		nextPutAll: self argumentName.	^wst contents</body><body package="Values Tools">pragmaMessageString	"&lt;String&gt;"	self subclassResponsibility</body><body package="Values Tools">pragmaString	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 30).	wst		nextPut: $&lt;;		nextPutAll: self pragmaMessageString;		nextPut: $&gt;.	^wst contents</body><body package="Values Tools">printExpression	"&lt;String&gt;"	self subclassResponsibility</body><body package="Values Tools">printSelector	"&lt;Symbol&gt;"	"the first part of the selector used by the print method to print its contents"	self subclassResponsibility</body><body package="Values Tools">setterName	"&lt;String&gt;"	^self name copyWith: $:</body><body package="Values Tools">sourceAccessorFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPutAll: self name;		crtab;		nextPutAll: '"&lt;';		nextPutAll: self typeName;		nextPut: $&gt;.	self comment notEmpty ifTrue: [		wst			crtab;			nextPutAll: self comment].	wst		nextPut: $";		cr;		crtab;		nextPut: $^;		nextPutAll: (self accessorExpressionFor: aTargetClass).	^wst contents</body><body package="Values Tools">typeName	"&lt;String&gt;"	^self type name asString</body></methods><methods><class-id>BindingSpecification</class-id> <category>accessing</category><body package="Values Tools">comment	"&lt;String&gt;"	^comment ifNil: [String new]</body><body package="Values Tools">default	^self typeName, ' new beImmutable'</body><body package="Values Tools">defaultFor: aTargetClass	^self default</body><body package="Values Tools">name	"&lt;String&gt;"	^selector asString</body><body package="Values Tools">passModeString	"for OpenTalk StSt #passInstVars"	^#default asString</body><body package="Values Tools">selector	"&lt;Symbol&gt;	required"	^selector</body><body package="Values Tools">type	"&lt;LiteralBindingReference&gt;	required"	"the class of the constant values"	^self subclassResponsibility</body><body package="Values Tools">valueIn: aValue	"&lt;Value | nil&gt;	the value of the receiver attribute in aValue"	^self subclassResponsibility</body></methods><methods><class-id>BindingSpecification</class-id> <category>testing</category><body package="Values Tools">isOptional	"&lt;Boolean&gt;"	^false</body></methods><methods><class-id>BindingSpecification</class-id> <category>initialize-release</category><body package="Values Tools">initializeSelector: selectorSymbol comment: commentString	selector := selectorSymbol.	(commentString notNil and: [	self comment ~= commentString]) ifTrue: [			comment := commentString].	self beImmutable</body></methods><methods><class-id>BindingSpecification</class-id> <category>printing</category><body package="Values Tools">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'selector' value: self selector).	args add: (printer optional: 'comment' value: comment).	^printer printvalue: self arguments: args</body></methods><methods><class-id>BindingSpecification class</class-id> <category>instance creation</category><body package="Values Tools">selector: selectorSymbol comment: commentString	| inst |	inst := self new.	inst initializeSelector: selectorSymbol comment: commentString.	^inst</body></methods><methods><class-id>BindingSpecification class</class-id> <category>instance creation optional</category><body package="Values Tools">selector: selectorSymbol	^self selector: selectorSymbol comment: nil</body></methods><methods><class-id>TypedConstantSpecification</class-id> <category>initialize-release</category><body package="Values Tools">initializeSelector: selectorSymbol comment: commentString type: typeLiteralBindingReference	selector := selectorSymbol.	(commentString notNil and: [	self comment ~= commentString]) ifTrue: [			comment := commentString].	type := typeLiteralBindingReference.	self beImmutable</body><body package="Values Tools">initializeSelector: selectorSymbol type: typeLiteralBindingReference	selector := selectorSymbol.	type := typeLiteralBindingReference.	self beImmutable</body></methods><methods><class-id>TypedConstantSpecification</class-id> <category>source generation</category><body package="Values Tools">printSelector	^#writeValue:</body></methods><methods><class-id>TypedConstantSpecification</class-id> <category>printing</category><body package="Values Tools">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'selector' value: self selector).	args add: (printer optional: 'comment' value: comment).	args add: (printer constant: 'type' value: self type).	^printer printvalue: self arguments: args</body></methods><methods><class-id>TypedConstantSpecification</class-id> <category>accessing</category><body package="Values Tools">type	"&lt;LiteralBindingReference&gt;	required"	"the class of the constant values"	^type</body></methods><methods><class-id>TypedConstantSpecification class</class-id> <category>instance creation</category><body package="Values Tools">selector: selectorSymbol	"type is required!	#selector:type: must be used to create a non empty instance"	^self shouldNotImplement</body><body package="Values Tools">selector: selectorSymbol comment: commentString type: typeLiteralBindingReference	| inst |	inst := self new.	inst		initializeSelector: selectorSymbol		comment: commentString		type: typeLiteralBindingReference.	^inst</body></methods><methods><class-id>TypedConstantSpecification class</class-id> <category>instance creation optional</category><body package="Values Tools">selector: selectorSymbol type: typeLiteralBindingReference	^self selector: selectorSymbol comment: nil type: typeLiteralBindingReference</body></methods><methods><class-id>CollectionSpecification</class-id> <category>testing</category><body package="Values Tools">isOptional	"empty collection is the default"	^true</body></methods><methods><class-id>CollectionSpecification</class-id> <category>accessing</category><body package="Values Tools">valueIn: aValue	^aValue instVarNamed: self selector asString</body></methods><methods><class-id>ConstantSpecification</class-id> <category>source generation</category><body package="Values Tools">accessorExpressionFor: aTargetClass	"&lt;String&gt;"	^self name</body><body package="Values Tools">pragmaMessageString	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPutAll: 'constant: ';		nextPutAll: self selector printString;		nextPutAll: ' type: ';		nextPutAll: self type printString.	^wst contents</body><body package="Values Tools">printExpression	^'constant: ', self name printString, ' value: self ', self name</body></methods><methods><class-id>ConstantSpecification</class-id> <category>accessing</category><body package="Values Tools">valueIn: aValue	^aValue perform: self selector</body></methods><methods><class-id>ConstantSpecification class</class-id> <category>test instances</category><body package="Values Tools">example	^ConstantSpecification selector: #name comment: 'first there were names' type: #{String}</body></methods><methods><class-id>ArraySpecification</class-id> <category>source generation</category><body package="Values Tools">exampleStringFor: aTargetClass	"&lt;String&gt;"	^'#(1 #a $x ''name'')'</body><body package="Values Tools">initializeExpressionFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPut: $(;		nextPutAll: self argumentName;		nextPutAll: ' notNil and: [';		cr;		tab;		nextPutAll: self argumentName;		nextPutAll: ' notEmpty]) ifTrue: [';		cr;		tab;		tab;		nextPutAll: self name;		nextPutAll: ' := (';		nextPutAll: (Array nameRelativeTo: aTargetClass);		nextPutAll: ' withAll: ';		nextPutAll: self argumentName;		nextPutAll: ') beImmutable]'.	^wst contents</body><body package="Values Tools">pragmaMessageString	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPutAll: 'arrayConstant: ';		nextPutAll: self selector printString.	^wst contents</body><body package="Values Tools">printExpression	^'array: ', self name printString, ' value: self ', self name</body><body package="Values Tools">printSelector	^#literalArraySourceFor:</body></methods><methods><class-id>ArraySpecification</class-id> <category>accessing</category><body package="Values Tools">default	^'#()'</body><body package="Values Tools">type	^#{Array}</body></methods><methods><class-id>ArraySpecification class</class-id> <category>test instances</category><body package="Values Tools">example	^ArraySpecification selector: #list comment: 'a list of things'</body></methods><methods><class-id>OptionalConstantSpecification</class-id> <category>accessing</category><body package="Values Tools">default	^default ifNil: [super default]</body><body package="Values Tools">valueIn: aValue	^aValue instVarNamed: self selector asString</body></methods><methods><class-id>OptionalConstantSpecification</class-id> <category>source generation</category><body package="Values Tools">initializeExpressionFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPut: $(;		nextPutAll: self argumentName;		nextPutAll: ' notNil and: [';		cr;		tab;		nextPutAll: 'self ';		nextPutAll: self name;		nextPutAll: ' ~= ';		nextPutAll: self argumentName;		nextPutAll: ']) ifTrue: [';		cr;		tab;		tab;		nextPutAll: self name;		nextPutAll: ' := ';		nextPutAll: self argumentName;		nextPut: $].	^wst contents</body><body package="Values Tools">pragmaMessageString	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPutAll: 'constant: ';		nextPutAll: self selector printString;		nextPutAll: ' type: ';		nextPutAll: self type printString;		nextPutAll: ' default: ';		nextPutAll: (default ifNil: ['nil'] ifNotNil: [self default printString]).	^wst contents</body><body package="Values Tools">printExpression	^'optional: ', self name printString, ' value: ', self name</body></methods><methods><class-id>OptionalConstantSpecification</class-id> <category>printing</category><body package="Values Tools">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'selector' value: self selector).	args add: (printer optional: 'comment' value: comment).	args add: (printer constant: 'type' value: self type).	args add: (printer optional: 'default' value: default).	^printer printvalue: self arguments: args</body></methods><methods><class-id>OptionalConstantSpecification</class-id> <category>initialize-release</category><body package="Values Tools">initializeSelector: selectorSymbol comment: commentString type: typeLiteralBindingReference default: defaultString	selector := selectorSymbol.	(commentString notNil and: [	self comment ~= commentString]) ifTrue: [			comment := commentString].	type := typeLiteralBindingReference.	(defaultString notNil and: [	self default ~= defaultString]) ifTrue: [			default := defaultString].	self beImmutable</body></methods><methods><class-id>OptionalConstantSpecification</class-id> <category>testing</category><body package="Values Tools">isOptional	^true</body></methods><methods><class-id>OptionalConstantSpecification class</class-id> <category>test instances</category><body package="Values Tools">example	^OptionalConstantSpecification		selector: #default		comment: 'if nothing is said'		type: #{String}		default: 'String new'</body></methods><methods><class-id>OptionalConstantSpecification class</class-id> <category>instance creation</category><body package="Values Tools">selector: selectorSymbol comment: commentString type: typeLiteralBindingReference default: defaultString	| inst |	inst := self new.	inst		initializeSelector: selectorSymbol		comment: commentString		type: typeLiteralBindingReference		default: defaultString.	^inst</body></methods><methods><class-id>OptionalConstantSpecification class</class-id> <category>instance creation optional</category><body package="Values Tools">selector: selectorSymbol comment: commentString type: typeLiteralBindingReference	^self		selector: selectorSymbol		comment: commentString		type: typeLiteralBindingReference		default: nil</body><body package="Values Tools">selector: selectorSymbol type: typeLiteralBindingReference	^self selector: selectorSymbol comment: nil type: typeLiteralBindingReference default: nil</body><body package="Values Tools">selector: selectorSymbol type: typeLiteralBindingReference default: defaultString	^self		selector: selectorSymbol		comment: nil		type: typeLiteralBindingReference		default: defaultString</body></methods><methods><class-id>DictionarySpecification</class-id> <category>accessing</category><body package="Values Tools">default	^self defaultFor: Object</body><body package="Values Tools">defaultFor: aTargetClass	^(Dictionary nameRelativeTo: aTargetClass) , ' new beImmutable'</body><body package="Values Tools">passModeString	^#value asString</body><body package="Values Tools">type	^#{Dictionary}</body></methods><methods><class-id>DictionarySpecification</class-id> <category>source generation</category><body package="Values Tools">exampleStringFor: aTargetClass	"&lt;String&gt;"	^'(' , (Valuemap nameRelativeTo: aTargetClass) , ' with: 1 -&gt; #symbol with: #key -&gt; ''string'')'</body><body package="Values Tools">initializeExpressionFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPut: $(;		nextPutAll: self argumentName;		nextPutAll: ' notNil and: [';		cr;		tab;		nextPutAll: self argumentName;		nextPutAll: ' notEmpty]) ifTrue: [';		cr;		tab;		tab;		nextPutAll: self name;		nextPutAll: ' := (';		nextPutAll: (Valuemap nameRelativeTo: aTargetClass);		nextPutAll: ' withAll: ';		nextPutAll: self argumentName;		nextPutAll: ') beImmutable]'.	^wst contents</body><body package="Values Tools">pragmaMessageString	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPutAll: 'dictionaryConstant: ';		nextPutAll: self selector printString.	^wst contents</body><body package="Values Tools">printExpression	^'dictionary: ', self name printString, ' value: self ', self name</body><body package="Values Tools">printSelector	^#literalDictionarySourceFor:</body></methods><methods><class-id>DictionarySpecification class</class-id> <category>test instances</category><body package="Values Tools">example	^DictionarySpecification selector: #properties comment: 'The Properties'</body></methods><methods><class-id>ValueSpecification</class-id> <category>source generation private</category><body package="Values Tools">addChange: aRefactoryChangeOrNil to: compositeChange	aRefactoryChangeOrNil ifNotNil: [compositeChange addChange: aRefactoryChangeOrNil]</body><body package="Values Tools">combinationsOf: elements	"&lt;SequenceableCollection of: (SequenceableCollection of: BindingSpecification)&gt;"	"sorted, so that all parameters are first and no optional parameters are last"	| head tail tailcombinations withHead |	elements isEmpty ifTrue: [		^#(#())].	head := elements first.	tail := elements copyFrom: 2 to: elements size.	tailcombinations := self combinationsOf: tail.	withHead := tailcombinations collect: [:combo | (Array with: head) , combo].	^withHead , tailcombinations</body><body package="Values Tools">exampleFor: aTargetClass	"&lt;AddMethodChange | nil&gt;"	| source |	aTargetClass isLeafClass ifFalse: [		^nil].	source := (aTargetClass class includesSelector: #example)		ifTrue: [			[	| example |				example := aTargetClass perform: #example.				example asMethodSourceNamed: 'example'			] on: Error do: [:ex |				self sourceExampleFor: aTargetClass]]		ifFalse: [self sourceExampleFor: aTargetClass].	^self addMethod: source for: aTargetClass class in: #'test instances'</body><body package="Values Tools">initializerFor: aTargetClass	"&lt;AddMethodChange | nil&gt;"	self constants isEmpty ifTrue: [		^nil].	^self		addMethod: (self sourceInitializerFor: aTargetClass)		for: aTargetClass		in: #'initialize-release'</body><body package="Values Tools">needsPassInstVars	"&lt;Boolean&gt;"	^self constants anySatisfy: [:constant | constant passModeString = #value asString]</body><body package="Values Tools">parameterCombinations	"&lt;SequenceableCollection of: (SequenceableCollection of: BindingSpecification)&gt;"	"sorted, so that all parameters are first and no optional parameters are last"	"each combinations contains the right constants in the original order"	| grouped required optional |	grouped := self constants groupedBy: [:c | c isOptional].	required := grouped at: false ifAbsent: [#()].	optional := grouped at: true ifAbsent: [#()].	^((self combinationsOf: optional) collect: [:optionals |		| selection |		selection := (required , optionals) asSet.		self constants select: [:c | selection includes: c]	]) reject: [:p |		p isEmpty]</body><body package="Values Tools">passInstVarsFor: aTargetClass	"&lt;AddMethodChange | nil&gt;"	self needsPassInstVars ifFalse: [		^nil].	[self sourcePassInstVarsOf: aTargetClass] on: NotFoundError do: [:ex |		^nil].	^self addMethod: (self sourcePassInstVarsOf: aTargetClass) for: aTargetClass in: #marshaling</body><body package="Values Tools">printSelector	^self class printSelector</body><body package="Values Tools">sourceConstructorFor: usedConstants	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 60).	usedConstants do: [:constant | wst nextPutAll: constant parameterString] separatedBy: [		wst space].	wst		crtab;		nextPutAll: '| inst |';		crtab;		nextPutAll: 'inst := self new.';		crtab;		nextPutAll: 'inst initialize';		nextPutAll: self constants first capitalizedName;		nextPut: $:;		space;		nextPutAll: (self constants first argumentOrNilStringWhen: (usedConstants includes: self constants first)).	(self constants copyFrom: 2 to: self constants size) do: [:constant |		wst			space;			nextPutAll: constant setterName;			space;			nextPutAll: (constant argumentOrNilStringWhen: (usedConstants includes: constant))].	wst		nextPut: $.;		crtab;		nextPutAll: '^inst'.	^wst contents</body><body package="Values Tools">sourceExampleFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 60).	wst		nextPutAll: 'example';		crtab;		nextPut: $^;		nextPutAll: aTargetClass name.	self constants isEmpty		ifTrue: [wst nextPutAll: ' new']		ifFalse: [		self constants do: [:constant |			wst				crtab;				tab;				nextPutAll: (constant exampleParameterStringFor: aTargetClass)]].	^wst contents</body><body package="Values Tools">sourceInitializeCallString	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 60).	wst		nextPutAll: 'initialize';		nextPutAll: self constants first capitalizedName;		nextPut: $:;		space;		nextPutAll: self constants first argumentName.	(self constants copyFrom: 2 to: self constants size) do: [:constant |		wst			space;			nextPutAll: constant parameterString].	^wst contents</body><body package="Values Tools">sourceInitializerFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 60).	wst nextPutAll: self sourceInitializeCallString.	self constants do: [:constant |		wst			crtab;			nextPutAll: (constant initializeExpressionFor: aTargetClass);			nextPut: $.].	wst		crtab;		nextPutAll: 'self beImmutable'.	^wst contents</body><body package="Values Tools">sourceOptionalConstructorFor: usedConstants	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 60).	usedConstants do: [:constant | wst nextPutAll: constant parameterString] separatedBy: [		wst space].	wst		crtab;		nextPutAll: '^self'.	self constants do: [:constant |		wst			space;			nextPutAll: constant setterName;			space;			nextPutAll: (constant argumentOrNilStringWhen: (usedConstants includes: constant))].	^wst contents</body><body package="Values Tools">sourcePassInstVarsOf: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 60).	wst		nextPutAll: #passInstVars asString;		crtab;		nextPut: $";		nextPutAll: 'for OpenTalk StSt';		nextPut: $";		cr;		crtab;		nextPutAll: '^#('.	aTargetClass allInstVarNames do: [:ivar |		| selector constant |		selector := ivar asSymbol.		constant := self constants detect: [:c | c selector = selector].		wst nextPutAll: constant passModeString] separatedBy: [		wst space].	wst nextPut: $).	^wst contents</body><body package="Values Tools">sourcePrintvalueWith	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 100).	wst		nextPutAll: #printvalueWith: asString;		nextPutAll: ' printer';		crtab;		nextPutAll: '| args |';		crtab;		nextPutAll: 'args := OrderedCollection new.'.	self constants do: [:constant |		wst			crtab;			nextPutAll: 'args add: (printer ';			nextPutAll: constant printExpression;			nextPutAll: ').'].	wst		crtab;		nextPutAll: '^printer printvalue: self arguments: args'.	^wst contents</body><body package="Values Tools">sourcePrintvalueWithFor: aTargetClass	"&lt;AddMethodChange | nil&gt;"	^self addMethod: self sourcePrintvalueWith for: aTargetClass in: #printing</body></methods><methods><class-id>ValueSpecification</class-id> <category>source generation</category><body package="Values Tools">addMethodsFor: aTargetClass to: compositeChange	aTargetClass hasSpecification ifTrue: [		| parameterCombinations |		(self changesForInstvarsOf: aTargetClass) do: [:change |			self addChange: change to: compositeChange].		parameterCombinations := self parameterCombinations.		self			addChange: (self				addMethod: (self sourceConstructorFor: parameterCombinations first)				for: aTargetClass class				in: #'instance creation')			to: compositeChange.		(parameterCombinations copyFrom: 2 to: parameterCombinations size) do: [:parameters |			self				addChange: (self					addMethod: (self sourceOptionalConstructorFor: parameters)					for: aTargetClass class					in: #'instance creation optional')				to: compositeChange].		self addChange: (self initializerFor: aTargetClass) to: compositeChange.		self constants do: [:constantSpec |			self addChange: (constantSpec accessorFor: aTargetClass) to: compositeChange]].	aTargetClass == Value ifTrue: [		^self].	aTargetClass hasSpecification ifTrue: [		self addChange: (self passInstVarsFor: aTargetClass) to: compositeChange.		self addChange: (self sourcePrintvalueWithFor: aTargetClass) to: compositeChange].	aTargetClass isLeafClass ifTrue: [		"should go into the test resources package"		self addChange: (self exampleFor: aTargetClass) to: compositeChange]</body><body package="Values Tools">changesForInstvarsOf: aTargetClass	"&lt;Collection of: Change&gt;"	| changes |	changes := OrderedCollection new.	changes addAll: (self changesForObsoleteInstVarsOf: aTargetClass).	changes addAll: (self classChangeForChangingInstVarsOf: aTargetClass).	^changes</body><body package="Values Tools">changesForObsoleteInstVarsOf: aTargetClass	| changes constantNames obsoleteInstvars methodsReferencingOldInstVars obsoleteConstructors |	changes := OrderedCollection new.	constantNames := self constants collect: [:const | const name].	obsoleteInstvars := aTargetClass instVarNames reject: [:varName |		constantNames includes: varName].	obsoleteInstvars isEmpty ifTrue: [		^changes].	methodsReferencingOldInstVars := obsoleteInstvars inject: Set new into: [:set :varName |		set addAll: (aTargetClass whichSelectorsAccess: varName).		set].	(methodsReferencingOldInstVars detect: [:selector | 'initialize*' match: selector asString] ifNone: [nil]) ifNotNil: [:initializer |		obsoleteConstructors := aTargetClass class whichSelectorsReferTo: initializer.		obsoleteConstructors do: [:constructor |			changes add: (RemoveMethodChange remove: constructor from: aTargetClass class)]].	methodsReferencingOldInstVars do: [:selector |		changes add: (RemoveMethodChange remove: selector from: aTargetClass)].	^changes</body><body package="Values Tools">classChangeForChangingInstVarsOf: aTargetClass	"&lt;SequenceableCollection of: AddClassChange&gt;"	| localConstants newInstvarString oldInstvarString change newDefinition |	localConstants := self constants reject: [:const | aTargetClass superclass allInstVarNames includes: const name].	newInstvarString := localConstants inject: String new into: [:string :const | string , const name , ' '].	oldInstvarString := aTargetClass instanceVariablesString.	newInstvarString = oldInstvarString ifTrue: [		^#()].	newDefinition := aTargetClass definition		copyReplaceAll: 'instanceVariableNames: ' , oldInstvarString printString		with: 'instanceVariableNames: ' , newInstvarString printString.	change := AddClassChange definition: newDefinition.	^Array with: change</body></methods><methods><class-id>ValueSpecification</class-id> <category>printing</category><body package="Values Tools">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer array: 'constants' value: self constants).	^printer printvalue: self arguments: args</body></methods><methods><class-id>ValueSpecification</class-id> <category>initialize-release</category><body package="Values Tools">initializeConstants: constantsArray	(constantsArray notNil and: [	constantsArray notEmpty]) ifTrue: [		constants := (Array withAll: constantsArray) beImmutable].	self beImmutable</body></methods><methods><class-id>ValueSpecification</class-id> <category>accessing</category><body package="Values Tools">constants	^constants ifNil: [#()]</body></methods><methods><class-id>ValueSpecification class</class-id> <category>accessing</category><body package="Values Tools">printSelector	^#printvalueWith:</body></methods><methods><class-id>ValueSpecification class</class-id> <category>instance creation</category><body package="Values Tools">constants: constantsArray	| inst |	inst := self new.	inst initializeConstants: constantsArray.	^inst</body></methods><methods><class-id>ValueSpecification class</class-id> <category>test instances</category><body package="Values Tools">example	^ValueSpecification constants: (Array		with: (ConstantSpecification			selector: #name			comment: 'first there were names'			type: #{String})		with: (OptionalConstantSpecification			selector: #default			comment: 'if nothing is said'			type: #{String}			default: 'String new')		with: (ArraySpecification selector: #list comment: 'a list of things')		with: (DictionarySpecification selector: #properties comment: 'The Properties'))</body><body package="Values Tools">exampleAllOptional	^ValueSpecification constants: (Array		with: (OptionalConstantSpecification			selector: #name			comment: 'first there were names'			type: #{String}			default: 'String new')		with: (OptionalConstantSpecification			selector: #default			comment: 'if nothing is said'			type: #{String}			default: 'String new')		with: (ArraySpecification selector: #list comment: 'a list of things')		with: (DictionarySpecification selector: #properties comment: 'The Properties'))</body><body package="Values Tools">exampleNoOptional	^ValueSpecification constants: (Array		with: (ConstantSpecification selector: #name type: #{String})		with: (ConstantSpecification selector: #default type: #{String})		with: (ConstantSpecification selector: #list type: #{Array})		with: (ConstantSpecification selector: #properties type: #{Valuemap}))</body></methods><methods><class-id>Tools.Trippy.ValuemapInspector</class-id> <category>private</category><body package="Values Tools">createInsertionUndo: partCollection before: anIndex	self shouldNotImplement</body><body package="Values Tools">refresh	"Keys in a dictionary are unordered, but for presentation arrange them	in the increasing order of their displayStrings. Do not use #collect: to collect	pairs, because #collect: coalesces equal elements, which we need to avoid."	| pairs originalSelections |	pairs := OrderedCollection new: object size.	object keys do: 		[:each | pairs add: (Inspector safeDisplayStringOf: each) -&gt; each].	linearizedParts := pairs collect: [:each | KeyedElement of: object at: each value].	originalSelections := self selections.	driver := self driverClass for: self.	driver refresh.	self selectAll: originalSelections</body></methods><methods><class-id>Graphics.Rectangle class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^1@2 extent: 20@10</body></methods><methods><class-id>DictionaryPrintargument class</class-id> <category>test instances</category><body package="Values Tools">example	^DictionaryPrintargument name: Printvalue new value: Printvalue new</body></methods><methods><class-id>Core.Date class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^Date d: 19 m: 5 y: 2006</body></methods><methods><class-id>ArrayPrintvalue class</class-id> <category>test instances</category><body package="Values Tools">example	^ArrayPrintvalue arguments: (Array		with: (Printargument name: 'selector' value: '#value')		with: (Printargument name: 'type' value: '#{Number}'))</body></methods><methods><class-id>Core.Object class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^self error: 'this is no literal object'</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Values Tools">asLiteralSource	"use #asSource"	self halt</body></methods><methods><class-id>Graphics.ColorValue class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^ColorValue red</body></methods><methods><class-id>Core.Timestamp class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^Timestamp d: 19 m: 5 y: 2006 h: 11 m: 7 s: 55</body></methods><methods><class-id>Printargument class</class-id> <category>test instances</category><body package="Values Tools">example	^Printargument		name: 'constant'		value: (ValuePrintvalue			classname: 'ConstantSpecification'			arguments: (Array				with: (Printargument name: 'selector' value: '#value')				with: (Printargument name: 'type' value: '#{Number}')))</body></methods><methods><class-id>Value class</class-id> <category>conformance testing</category><body package="Values Tools">allLeafClassesHaveEmptyInstance	"tests that #asSource and #= are implemented"	"self allLeafClassesHaveEmptyInstance"	| nonConforming |	nonConforming := Value leafClasses reject: [:class |		class new asSource = (class name asString , ' new')].	nonConforming notEmpty ifTrue: [		^self error: 'some classes do not conform to the Value protocol'].	^true</body><body package="Values Tools">allLeafClassesHaveWorkingExample	"tests that #example is implemented and works"	"self allLeafClassesHaveWorkingExample"	| nonConforming |	nonConforming := Value leafClasses reject: [:class |		(((class class includesSelector: #localSpecification) and: [		class class includesSelector: #example]) or: [			true]) and: [			class example asSource = (class evaluate: (class example asSourceFor: class)) asSource]].	nonConforming notEmpty ifTrue: [		^self error: 'some classes do not conform to the Value protocol'].	^true</body><body package="Values Tools">allValuesHavePrinters	"tests that #printvalueWith: is implemented when there is state"	"self allValuesHavePrinters"	| nonConforming |	nonConforming := Value subclassesWithConstants reject: [:class |		class includesSelector: ValueSpecification printSelector].	nonConforming notEmpty ifTrue: [		^self error: 'some classes do not conform to the Value protocol'].	^true</body></methods><methods><class-id>Value class</class-id> <category>pragmas</category><body package="Values Tools">constant: aSymbol class: aLiteralBindingReference	^ConstantSpecification selector: aSymbol type: aLiteralBindingReference</body><body package="Values Tools">constant: aSymbol class: aLiteralBindingReference comment: commentString	^ConstantSpecification		selector: aSymbol		comment: commentString		type: aLiteralBindingReference</body></methods><methods><class-id>Value class</class-id> <category>source generation</category><body package="Values Tools">differentPrintMethods	"self differentPrintMethods"	"construct change objects for all printers with different source code than generated"	| change |	change := Refactory.Browser.CompositeRefactoryChange named: 'Different print methods in subclasses of ' , self name asString.	self subclassesWithConstants do: [:aClass |		(aClass specification sourcePrintvalueWithFor: aClass) ifNotNil: [:aRefactoryChangeOrNil |			change addChange: aRefactoryChangeOrNil]].	change changes isEmpty ifTrue: [		^Dialog warn: 'No changes'].	change inspect</body></methods><methods><class-id>Value class</class-id> <category>compiling</category><body package="Values Tools">evaluate: source	^self compilerClass		evaluate: source		for: self		in: self environment		notifying: nil		logged: false</body></methods><methods><class-id>Value class</class-id> <category>test instances</category><body package="Values Tools">example	"&lt;Value&gt;"	^self new</body></methods><methods><class-id>Value class</class-id> <category>source generation</category><body package="Values Tools">generateMethods	"construct change objects and opens the list for the user to execute"	| change |	(self hasSpecification not and: [	self isLeafClass not]) ifTrue: [			^Dialog warn: 'no specification found and abstract'].	change := Refactory.Browser.CompositeRefactoryChange named: 'Create value methods for ' , self name asString.	self specification addMethodsFor: self to: change.	change changes isEmpty ifTrue: [		^Dialog warn: 'No changes'].	change inspect</body></methods><methods><class-id>Value class</class-id> <category>testing</category><body package="Values Tools">hasSpecification	^self class includesSelector: #localSpecification</body></methods><methods><class-id>Value class</class-id> <category>testing class hierarchy</category><body package="Values Tools">isLeafClass	^self subclasses isEmpty</body></methods><methods><class-id>Value class</class-id> <category>accessing class hierarchy</category><body package="Values Tools">leafClasses	^self allSubclasses select: [:subclass | subclass isLeafClass]</body></methods><methods><class-id>Value class</class-id> <category>test instances</category><body package="Values Tools">literalExample	^self example</body></methods><methods><class-id>Value class</class-id> <category>pragmas</category><body package="Values Tools">map: aSymbol	^DictionarySpecification selector: aSymbol</body><body package="Values Tools">map: aSymbol comment: commentString	^DictionarySpecification selector: aSymbol comment: commentString</body><body package="Values Tools">optional: aSymbol class: aLiteralBindingReference default: aString	^OptionalConstantSpecification selector: aSymbol type: aLiteralBindingReference default: aString</body><body package="Values Tools">optional: aSymbol class: aLiteralBindingReference default: aString comment: commentString	^OptionalConstantSpecification		selector: aSymbol		comment: commentString		type: aLiteralBindingReference		default: aString</body><body package="Values Tools">sequence: aSymbol	^ArraySpecification selector: aSymbol</body><body package="Values Tools">sequence: aSymbol comment: commentString	^ArraySpecification selector: aSymbol comment: commentString</body></methods><methods><class-id>Value class</class-id> <category>specification</category><body package="Values Tools">specification	"&lt;ValueSpecification&gt;"	"the comprehensive specification of the constants of this class"	| constants superclasses |	constants := OrderedCollection new.	superclasses := self withAllSuperclasses reverse.	"from superclasses to subclasses"	superclasses remove: Object.	superclasses remove: Value.	superclasses do: [:aSuperclass |		(aSuperclass class includesSelector: #localSpecification) ifTrue: [			| pragmas consts |			pragmas := Pragma allInMethod: (aSuperclass class compiledMethodAt: #localSpecification).			consts := pragmas collect: [:pragma | Value perform: pragma keyword withArguments: pragma arguments].			consts do: [:constant |				(constants detect: [:c | c name = constant name] ifNone: [nil]) ifNotNil: [:c |					constants remove: c	"subclasses overwrite superclass specifications"].				constants add: constant]]].	^ValueSpecification constants: constants</body></methods><methods><class-id>Value class</class-id> <category>accessing class hierarchy</category><body package="Values Tools">subclassesWithConstants	^Value allSubclasses select: [:aClass | aClass instVarNames notEmpty]</body></methods><methods><class-id>Value class</class-id> <category>accessing</category><body package="Values Tools">toolListIcon	^ListIconLibrary visualFor: #value</body></methods><methods><class-id>Value</class-id> <category>source generation</category><body package="Values Tools">addAsMethod	"&lt;(Association key: class value: Symbol) | nil&gt;	generate a method for the receiver"	^self addAsMethodNamed: self selectorString</body><body package="Values Tools">addAsMethodNamed: initialName	"&lt;Symbol | nil&gt;	generate a method for the receiver"	| selectorString selector |	self isUsefulTestInstance ifFalse: [		^nil].	selectorString := Dialog		request: 'class method name in ' , self class name asString		initialAnswer: initialName.	selectorString isEmpty ifTrue: [		^nil].	selector := selectorString asSymbol.	(self class respondsTo: selector) ifTrue: [		Dialog warn: 'Method ' , selectorString , ' already exists. Please choose another name'.		^self addAsMethodNamed: selectorString].	(self		addMethodNamed: selector		for: self class class		in: self methodProtocol		package: (Store.Registry packageNamed: self class package name)) ifNotNil: #execute.	^self class class -&gt; selector</body><body package="Values Tools">addAsTestInstanceIn: packageName	"generate a method for the receiver"	"Replace an existing instance when better"	| selector |	self isUsefulTestInstance ifFalse: [		^self].	selector := self selectorString asSymbol.	(self isBetterTestInstanceSelector: selector) ifFalse: [		^self].	(self		addMethodNamed: selector		for: self class class		in: self methodProtocol		package: (Store.Registry packageNamed: packageName)) ifNotNil: #execute</body><body package="Values Tools">addMethod: source for: target in: protocol	"&lt;AddMethodChange | nil&gt;"	| pretty |	(target needs: source) ifFalse: [		^nil].	pretty := (Refactory.Browser.RBParser parseMethod: source) formattedCode.	^Refactory.Browser.AddMethodChange compile: pretty in: target classified: protocol</body><body package="Values Tools">addMethod: source for: target in: protocol package: aPackageModel	"&lt;AddMethodChange | nil&gt;"	| pretty change |	(target needs: source) ifFalse: [		^nil].	pretty := (Refactory.Browser.RBParser parseMethod: source) formattedCode.	change := Refactory.Browser.AddMethodChange compile: pretty in: target classified: protocol.	change package: aPackageModel.	^change</body><body package="Values Tools">addMethodNamed: selector for: target in: protocol	"&lt;AddMethodChange | nil&gt;"	^self addMethod: (self asMethodSourceNamed: selector) for: target in: protocol</body><body package="Values Tools">addMethodNamed: selector for: aMetaClass in: protocol package: aPackageModel	"&lt;AddMethodChange | nil&gt;"	^self		addMethod: (self asMethodSourceFor: aMetaClass named: selector)		for: aMetaClass		in: protocol		package: aPackageModel</body><body package="Values Tools">asMethodSourceFor: aMetaClass named: selector	| wst |	wst := WriteStream on: (String new: 200).	wst		nextPutAll: selector;		crtab;		nextPut: $^;		nextPutAll: (self asSourceFor: aMetaClass soleInstance).	^wst contents</body><body package="Values Tools">asMethodSourceNamed: selector	| wst |	wst := WriteStream on: (String new: 200).	wst		nextPutAll: selector;		crtab;		nextPut: $^;		nextPutAll: self asSource.	^wst contents</body><body package="Values Tools">betterTestInstanceThan: aValue	"&lt;Boolean&gt;	true, iff the receiver is better as a test instance than aValue"	^true</body></methods><methods><class-id>Value</class-id> <category>user interface</category><body package="Values Tools">inspectorActions	^Array with: (Tools.Trippy.Action label: 'Save as method...' block: [		self addAsMethod			ifNotNil: [:assoc |			| md |			md := MethodDefinition class: assoc key selector: assoc value.			MethodCollector new				openListBrowserOn: (Array with: md)				label: 'Generated Method'				initialSelection: nil]			ifNil: [			self halt]])</body></methods><methods><class-id>Value</class-id> <category>source generation</category><body package="Values Tools">isBetterTestInstanceSelector: aSymbol	(self class respondsTo: aSymbol) ifFalse: [		^true].	^self betterTestInstanceThan: (self class perform: aSymbol)</body><body package="Values Tools">isUsefulTestInstance	^self notEmpty</body><body package="Values Tools">methodProtocol	^#'test instances'</body><body package="Values Tools">newSelectorBasedOn: aString	"&lt;Symbol | nil&gt;	return a new selector by adding '_&lt;Integer&gt;' to the base selector"	| selector count |	selector := aString asSymbol.	count := 1.	[self class respondsTo: selector] whileTrue: [		selector := (aString , '_' , count printString) asSymbol.		count := count + 1].	^selector</body><body package="Values Tools">selectorString	"&lt;String&gt;"	"if this object should be savable, implement this method to return a suitable unique string"	^'example', self class name asString</body></methods><methods><class-id>Core.ArithmeticValue class</class-id> <category>constants access</category><body package="Values Tools">literalExample	^self unity toMinimumGenerality</body></methods><methods><class-id>Core.Time class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^Time h: 11 m: 8 s: 28</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>printing</category><body package="Values Tools">literalExample	^nil</body></methods><methods><class-id>Core.Behavior</class-id> <category>source generation</category><body package="Values Tools">needs: source	"&lt;Boolean&gt;"	| selector parseTree classAndMethod |	parseTree := Refactory.Browser.RBParser parseMethod: source.	selector := parseTree selector.	(self canUnderstand: selector) ifFalse: [		^true].	classAndMethod := self findSelector: selector.	^(classAndMethod first parseTreeFor: selector) ~= parseTree</body></methods><methods><class-id>Core.Symbol class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^#symbol</body></methods><methods><class-id>Core.Boolean class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^true</body></methods><methods><class-id>LiteralPrintvalue class</class-id> <category>test instances</category><body package="Values Tools">example	^LiteralPrintvalue string: '(Date d: 8 m: 7 y: 2007)'</body></methods><methods><class-id>Core.String class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^'a string'</body></methods><methods><class-id>Core.Duration class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^42 nanoseconds</body></methods><methods><class-id>ValuePrintvalue class</class-id> <category>test instances</category><body package="Values Tools">example	^ValuePrintvalue		classname: 'ConstantSpecification'		arguments: (Array			with: (Printargument name: 'selector' value: '#value')			with: (Printargument name: 'type' value: '#{Number}'))</body></methods><methods><class-id>Kernel.GeneralBindingReference class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^#{Object}</body></methods><methods><class-id>Core.Collection</class-id> <category>comparing</category><body package="Values Tools">betterTestInstanceThan: aCollection	"&lt;Boolean&gt;	true, iff the receiver is better as a test instance than aValue"	^self size &gt;= aCollection size</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>class probes</category><body package="Values Tools">isValueClassSelected	^self isClassSelected and: [	(self selectedClass includesBehavior: Value) or: [	self selectedClass includesBehavior: Value class]]</body></methods><methods><class-id>Core.ByteArray class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^#[42]</body></methods><methods><class-id>Core.Valuemap</class-id> <category>printing</category><body package="Values Tools">describeOn: textStream	textStream nextPutAllText: self class name asString asText allBold.	textStream nextPutAll: ' new'.	self keysAndValuesDo: [:key :value |		textStream			cr;			tab;			nextPutAll: 'at: ' , key printString , ' put: '.		textStream nextPutAllText: value printString asText allBold.		textStream nextPut: $;].	textStream		cr;		tab;		nextPutAll: 'yourself'</body><body package="Values Tools">descriptionText	"&lt;Text&gt;	nicely formated for the user"	| wst |	wst := TextStream on: (String new: 200).	self describeOn: wst.	^wst contents</body></methods><methods><class-id>Core.Valuemap</class-id> <category>user interface</category><body package="Values Tools">inspectorClasses	^Array		with: Tools.Trippy.ValuemapInspector		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>Core.Character class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^$a</body></methods><methods><class-id>DictionaryPrintvalue class</class-id> <category>test instances</category><body package="Values Tools">example	^DictionaryPrintvalue arguments: (Array		with: (DictionaryPrintargument			name: (LiteralPrintvalue string: '123')			value: (LiteralPrintvalue string: '#value'))		with: (DictionaryPrintargument			name: (LiteralPrintvalue string: '#other')			value: (LiteralPrintvalue string: '#{Number}')))</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>DictionaryInspector</name><environment>Tools.Trippy</environment><super>Tools.Trippy.PartListAbstractInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>linearizedParts valueOrKeyHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Value</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><class><name>Valuemap</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>order </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><class><name>BrowserNavigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractBrowserNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>history future updateHistoryBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class></st-source>