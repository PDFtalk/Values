<?xml version="1.0"?><st-source><!-- Name: Values ProjectNotice: The MIT LicenseCopyright © 2009-2018 Christian HaiderPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.BundleName: Values ProjectBundleStructure: a Store.BundleForParcelComment: Values are simple immutable literal objects.Package 'Values' contains the runtime code.Package 'Values Testing' contains tests for Values.Package 'Value Tools' contains the generators to define Values in the development environment.For a comprehensive descriptions see the paper "Complex Values in Smalltalk" held at ESUG 2009 by Thomas Schrader and Christian Haider.See https://wiki.pdftalk.de/doku.php?id=complexvalues for more information.PackageName: Values ProjectParcel: nilParcelName: Values ProjectPrerequisiteParcels: #(#('SUnitToo' ''))Version: 3.0.4.0Date: 2:01:25 PM October 19, 2024 --><time-stamp>From VisualWorks®, 9.4 of 5. Januar 2024 on 19. Oktober 2024 at 14:01:25</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>ValueTestingNamespace</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>Values Tools Testing</package></attributes></name-space><comment><name-space-id>ValueTestingNamespace</name-space-id><body>A Namespace for testing purposes.Used for testing Values in other namespaces named Array, Dictionary and OrderedDictionary</body></comment><class><name>Value</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>Value</class-id><body>Value is the abstract root object of values (literal objects).All Value classes which have subclasses are considered abstract. Only leaf classes can have instances!Literal objects are created immutable with constructors.The instance variables are object constants.Subclasses must implement the following messages:	class specification		localSpecification</body></comment><class><name>Emitter</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>printer stream level </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>Emitter</class-id><body>Emitter outputs a Printvalue as formatted source code to a stream.Subclasses write source or text.This implements the second pass of the source generation for Values.Instance Variables	printer	&lt;ValuePrinter&gt;					the printer to resolve namespace names	level	&lt;Integer&gt;						the indention level	stream	&lt;WriteStream | TextStream&gt;		the output stream</body></comment><class><name>Valuemap</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>order </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>Core.Valuemap</class-id><body>A Valuemap is an ordered dictionary preserving the order in which entries are added.Instances are also used as ordered volatile dictionary, not just as value.In VisualWorks, Valuemap is subclassed from Dictionary to inherit the dictionary API.Instance Variables:	order	&lt;SequenceableCollection of: Object&gt;		the ordered keysThe class used to be named OrderedDictionary, but was renamed for dialect compatibility with Pharo, which has a class named OrderedDictionary with different semantics.</body></comment><class><name>ValuePrinter</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>target </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>ValuePrinter</class-id><body>ValuePrinter creates the source for a Value.For each level, a new ValuePrinter is created.The target class is the compilation target of the created source, as if the source is compiled as method of that class.The scoping from the target defines how class names are printed (with or without namespaces).</body></comment><class><name>Printargument</name><environment>Smalltalk</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>Printargument</class-id><body>A Printargument holds the data to print one instance variable (constant) and its value.	- name 	&lt;String&gt; 		the name of the argument	- value 	&lt;Printvalue&gt;	the print value of the valueWith Printvalue it represents the source for a Value</body></comment><class><name>Printvalue</name><environment>Smalltalk</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>Printvalue</class-id><body>A Printvalue holds a representation of a Value to be printed.It consists of	- classname 	&lt;String&gt;										properly resolved against a target class (#name or #fullName)	- arguments 	&lt;SequenceableCollection of: Printargument&gt;		the list of arguments with constructor variable name and a PrintvaluePrintvalues are created when printing the source for a Value in the first pass. The second pass takes the Printvalue and produces a nicely indented soure string for the value.</body></comment><class><name>SourceEmitter</name><environment>Smalltalk</environment><super>Emitter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>SourceEmitter</class-id><body>SourceEmitter outputs source code.</body></comment><class><name>TextEmitter</name><environment>Smalltalk</environment><super>Emitter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>TextEmitter</class-id><body>TextEmitter outputs a descriptive text.</body></comment><class><name>DictionaryPrintargument</name><environment>Smalltalk</environment><super>Printargument</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>DictionaryPrintargument</class-id><body>DictionaryPrintargument holds the Printvalues for key and value of an entry in a dictionary.Both key and value can be Values</body></comment><class><name>ValuePrintvalue</name><environment>Smalltalk</environment><super>Printvalue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classname arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>ValuePrintvalue</class-id><body>ValuePrintvalue holds the data to print a Value.Instance Variables:	arguments	&lt;SequenceableCollection of: (Printargument | EmptyArgument)&gt;	the arguments	classname	&lt;String&gt;														the namespace aware name of the class</body></comment><class><name>LineEmitter</name><environment>Smalltalk</environment><super>SourceEmitter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>LineEmitter</class-id><body>Emits source as one line</body></comment><class><name>ArrayPrintvalue</name><environment>Smalltalk</environment><super>Printvalue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>ArrayPrintvalue</class-id><body>ArrayPrintvalue is a special Printvalue for sequentiable collections of Values</body></comment><class><name>BlockEmitter</name><environment>Smalltalk</environment><super>SourceEmitter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>BlockEmitter</class-id><body>Emits source as indented block</body></comment><class><name>LiteralPrintvalue</name><environment>Smalltalk</environment><super>Printvalue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>LiteralPrintvalue</class-id><body>LiteralPrintvalue is a Printvalue for literals.Instance Variables:	string	&lt;String&gt;	the representation as a string</body></comment><class><name>TextBlockEmitter</name><environment>Smalltalk</environment><super>TextEmitter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>TextBlockEmitter</class-id><body>TextBlockEmitter emits text as indented block</body></comment><class><name>DictionaryPrintvalue</name><environment>Smalltalk</environment><super>Printvalue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arguments isOrdered </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>DictionaryPrintvalue</class-id><body>DictionaryPrintvalue is used for printing DictionariesInstance Variables:	arguments	&lt;SequenceableCollection of DictionaryPrintargument&gt;	the Printarguments for each entry</body></comment><class><name>TextLineEmitter</name><environment>Smalltalk</environment><super>TextEmitter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>TextLineEmitter</class-id><body>TextLineEmitter emits text as one line</body></comment><class><name>ValueTest</name><environment>Smalltalk</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Testing</package></attributes></class><class><name>Testvalue</name><environment>Smalltalk</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constant optional array dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Testing</package></attributes></class><comment><class-id>Testvalue</class-id><body>Testvalue is a resource class for testing values</body></comment><class><name>ColorValueTest</name><environment>Smalltalk</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>black white </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Testing</package></attributes></class><class><name>ValuePrinterTest</name><environment>Smalltalk</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Testing</package></attributes></class><comment><class-id>ValuePrinterTest</class-id><body>Tests for the source strings of Values</body></comment><class><name>ValuemapTest</name><environment>Smalltalk</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Testing</package></attributes></class><comment><class-id>ValuemapTest</class-id><body>Tests for the behavior of OrderedDictionary as Dictionary and as Value</body></comment><class><name>ValueSpecification</name><environment>Smalltalk</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constants </inst-vars><class-inst-vars></class-inst-vars><imports>			Refactory.Browser.*			</imports><category></category><attributes><package>Values Tools</package></attributes></class><comment><class-id>ValueSpecification</class-id><body>ValueSpecification describes the structure of a Value classInstance Variables:	constants	&lt;SequenceableCollection of: BindingSpecification&gt;	the constants (inst vars) of the Value class</body></comment><class><name>BindingSpecification</name><environment>Smalltalk</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector comment </inst-vars><class-inst-vars></class-inst-vars><imports>			Refactory.Browser.*			</imports><category></category><attributes><package>Values Tools</package></attributes></class><comment><class-id>BindingSpecification</class-id><body>BindingSpecification describes one constant (slot, instvar) of a Value class.Subclasses exist for different types.Part of a ValueSpecification. Used for source generating.Subclasses must implement the following messages:	accessing		type	source generation		pragmaMessageString		printExpressionWithNewline:		printSelectorInstance Variables:	selector		&lt;Symbol&gt;	the instvar</body></comment><class><name>ValuemapInspector</name><environment>Tools.Trippy</environment><super>Tools.Trippy.DictionaryInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Tools</package></attributes></class><comment><class-id>Tools.Trippy.ValuemapInspector</class-id><body>Inspector leaving the keys in their proper order</body></comment><class><name>ScopeTest</name><environment>Smalltalk</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Tools Testing</package></attributes></class><comment><class-id>ScopeTest</class-id><body>Tests for the scope or visibility between classes.Values write their source with or without namespaces, depending on the scope.</body></comment><class><name>ValueGenerationTest</name><environment>Smalltalk</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Tools Testing</package></attributes></class><comment><class-id>ValueGenerationTest</class-id><body>Tests for the various parts of the source code generation</body></comment><class><name>Valuemap</name><environment>ValueTestingNamespace</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Tools Testing</package></attributes></class><comment><class-id>ValueTestingNamespace.Valuemap</class-id><body>redefinition of Valuemap.Used to test the correct source string for classes which shadow the internally used system classes (Array, Dictionary, Valuemap)</body></comment><class><name>Dictionary</name><environment>ValueTestingNamespace</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Tools Testing</package></attributes></class><comment><class-id>ValueTestingNamespace.Dictionary</class-id><body>redefinition of Dictionary.Used to test the correct source string for classes which shadow the internally used system classes (Array, Dictionary, OrderedDictionary)</body></comment><class><name>Array</name><environment>ValueTestingNamespace</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Tools Testing</package></attributes></class><comment><class-id>ValueTestingNamespace.Array</class-id><body>redefinition of Array.Used to test the correct source string for classes which shadow the internally used system classes (Array, Dictionary, OrderedDictionary)</body></comment><class><name>TypedConstantSpecification</name><environment>Smalltalk</environment><super>BindingSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Tools</package></attributes></class><comment><class-id>TypedConstantSpecification</class-id><body>TypedConstantSpecification specifies a simple constant with a type. Subclasses define mandatory and optional versions</body></comment><class><name>CollectionSpecification</name><environment>Smalltalk</environment><super>BindingSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Tools</package></attributes></class><comment><class-id>CollectionSpecification</class-id><body>CollectionSpecification specifies a collecion constant: Array or Dictionary</body></comment><class><name>ConstantSpecification</name><environment>Smalltalk</environment><super>TypedConstantSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Tools</package></attributes></class><comment><class-id>ConstantSpecification</class-id><body>ConstantSpecification specifies a simple mandatory constant with a type</body></comment><class><name>ArraySpecification</name><environment>Smalltalk</environment><super>CollectionSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Tools</package></attributes></class><comment><class-id>ArraySpecification</class-id><body>ArraySpecification specifies an Array constant</body></comment><class><name>OptionalConstantSpecification</name><environment>Smalltalk</environment><super>TypedConstantSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>default </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Tools</package></attributes></class><comment><class-id>OptionalConstantSpecification</class-id><body>OptionalConstantSpecification specifies a simple optional constant with a type and a default</body></comment><class><name>DictionarySpecification</name><environment>Smalltalk</environment><super>CollectionSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values Tools</package></attributes></class><comment><class-id>DictionarySpecification</class-id><body>DictionarySpecification specifies a Dictionary constant</body></comment><shared-variable><name>NamedValuesRegistry</name><environment>Value</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Values</package></attributes></shared-variable><methods><class-id>Value class</class-id> <category>pragmas</category><body package="Values">specificationPragmas	&lt;pragmas: #class&gt;	^#(		#constant:class:		#constant:class:comment:				#optional:class:default:		#optional:class:default:comment:				#sequence:		#sequence:comment:		"#sequence:elements:comment:"				#map:		#map:comment:		"#map:keys:values:comment:"	)</body></methods><methods><class-id>Printargument class</class-id> <category>specification</category><body package="Values">localSpecification	&lt;constant: #name class: #{String}&gt;	&lt;constant: #value class: #{Printvalue}&gt;</body></methods><methods><class-id>DictionaryPrintargument class</class-id> <category>specification</category><body package="Values">localSpecification	&lt;constant: #name class: #{Printvalue}&gt;	&lt;constant: #value class: #{Printvalue}&gt;</body></methods><methods><class-id>ValuePrintvalue class</class-id> <category>specification</category><body package="Values">localSpecification	&lt;constant: #classname class: #{String}&gt;	&lt;sequence: #arguments&gt;</body></methods><methods><class-id>ArrayPrintvalue class</class-id> <category>specification</category><body package="Values">localSpecification	&lt;sequence: #arguments&gt;</body></methods><methods><class-id>LiteralPrintvalue class</class-id> <category>specification</category><body package="Values">localSpecification	&lt;constant: #string class: #{String}&gt;</body></methods><methods><class-id>DictionaryPrintvalue class</class-id> <category>specification</category><body package="Values">localSpecification	&lt;sequence: #arguments&gt;	&lt;optional: #isOrdered class: #{Boolean} default: 'false'&gt;</body></methods><methods><class-id>Testvalue class</class-id> <category>specification</category><body package="Values Testing">localSpecification	&lt;constant: #constant class: #{Symbol}&gt;	&lt;optional: #optional class: #{Symbol} default: '#none'&gt;	&lt;sequence: #array&gt;	&lt;map: #dictionary&gt;</body></methods><methods><class-id>ValueSpecification class</class-id> <category>specification</category><body package="Values Tools">localSpecification	&lt;sequence: #constants&gt;</body></methods><methods><class-id>BindingSpecification class</class-id> <category>specification</category><body package="Values Tools">localSpecification	&lt;constant: #selector class: #{Symbol}&gt;	&lt;optional: #comment class: #{String} default: 'String new'&gt;</body></methods><methods><class-id>ValueTestingNamespace.Valuemap class</class-id> <category>specification</category><body package="Values Tools Testing">localSpecification	&lt;map: #value&gt;</body></methods><methods><class-id>ValueTestingNamespace.Dictionary class</class-id> <category>specification</category><body package="Values Tools Testing">localSpecification	&lt;map: #value&gt;</body></methods><methods><class-id>ValueTestingNamespace.Array class</class-id> <category>specification</category><body package="Values Tools Testing">localSpecification	&lt;sequence: #value&gt;</body></methods><methods><class-id>TypedConstantSpecification class</class-id> <category>specification</category><body package="Values Tools">localSpecification	&lt;constant: #type class: #{LiteralBindingReference}&gt;</body></methods><methods><class-id>OptionalConstantSpecification class</class-id> <category>specification</category><body package="Values Tools">localSpecification	&lt;optional: #default class: #{String} default: 'super default'&gt;</body></methods><methods><class-id>Tools.ListIconLibrary class</class-id> <category>resources</category><body package="Values Tools">value16x16mask	"Tools.UIMaskEditor new openOnClass: self andSelector: #value16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 96 0 0 3 96 0 0 15 248 0 0 15 248 0 0 3 96 0 0 15 248 0 0 15 248 0 0 3 96 0 0 3 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>class probes</category><body package="Values Tools">generateMethodsForValue	&lt;menuItem: 'add Value methods...'			nameKey: #generateMethodsForValue			enablement: #isValueClassSelected			indication: nil			menu: #(#classMenu )			position: 15.1&gt;	| target |	target := self selectedClass isMeta		ifTrue: [self selectedClass soleInstance]		ifFalse: [self selectedClass].	target generateMethods</body></methods><methods><class-id>Tools.ListIconLibrary class</class-id> <category>resources</category><body package="Values Tools">value16x16	"Tools.UIMaskEditor new openOnClass: self andSelector: #value16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2120 2120 2120)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3180 3180 3180)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 36 0 0 10 24 0 0 170 101 64 0 169 149 64 0 6 20 0 0 153 85 64 0 101 85 64 0 5 20 0 0 5 20 0 0 0 0 0 0 0 0 0 0 0 0 0])</body></methods><methods><class-id>Value</class-id> <category>comparing</category><body package="Values">= anObject	"all instvars must be equal"	^self isEqualValue: anObject</body><body package="Values">hash	^(1 to: self class instSize) inject: 0 into: [:hash :i | hash bitXor: (self instVarAt: i) hash]</body><body package="Values">isEqualValue: anObject	self == anObject ifTrue: [		^true].	self class = anObject class ifFalse: [		^false].	1 to: self class instSize do: [:i |		((self instVarAt: i) isEqualValue: (anObject instVarAt: i)) ifFalse: [			^false]].	^true</body></methods><methods><class-id>Value</class-id> <category>testing</category><body package="Values">isEmpty	^self = self class new</body><body package="Values">notEmpty	^self isEmpty not</body></methods><methods><class-id>Value</class-id> <category>printing</category><body package="Values">printOn: stream	stream nextPutAll: self asSource</body><body package="Values">printvalueWith: printer	^printer printvalue: self arguments: #()</body></methods><methods><class-id>Value</class-id> <category>marshaling</category><body package="Values">passMode	"for OpenTalk StSt (Smalltalk to Smalltalk)"	^#value</body></methods><methods><class-id>Value</class-id> <category>copying</category><body package="Values">postCopy	super postCopy.	self beImmutable</body></methods><methods><class-id>Value</class-id> <category>source generation</category><body package="Values Tools">addAsMethod	"&lt;(Association key: class value: Symbol) | nil&gt;	generate a method for the receiver"	^self addAsMethodNamed: self selectorString</body><body package="Values Tools">addAsMethodNamed: initialName	"&lt;Symbol | nil&gt;	generate a method for the receiver"	| selectorString selector |	self isUsefulTestInstance ifFalse: [		^nil].	selectorString := Dialog		request: 'class method name in ' , self class name asString		initialAnswer: initialName.	selectorString isEmpty ifTrue: [		^nil].	selector := selectorString asSymbol.	(self class respondsTo: selector) ifTrue: [		Dialog warn: 'Method ' , selectorString , ' already exists. Please choose another name'.		^self addAsMethodNamed: selectorString].	(self		addMethodNamed: selector		for: self class class		in: self methodProtocol		package: (Store.Registry packageNamed: self class package name)) ifNotNil: #execute.	^self class class -&gt; selector</body><body package="Values Tools">addAsTestInstanceIn: packageName	"generate a method for the receiver"	"Replace an existing instance when better"	| selector |	self isUsefulTestInstance ifFalse: [		^self].	selector := self selectorString asSymbol.	(self isBetterTestInstanceSelector: selector) ifFalse: [		^self].	(self		addMethodNamed: selector		for: self class class		in: self methodProtocol		package: (Store.Registry packageNamed: packageName)) ifNotNil: #execute</body><body package="Values Tools">addMethod: source for: target in: protocol	"&lt;AddMethodChange | nil&gt;"	| pretty |	(target needs: source) ifFalse: [		^nil].	pretty := (Refactory.Browser.RBParser parseMethod: source) formattedCode.	^Refactory.Browser.AddMethodChange compile: pretty in: target classified: protocol</body><body package="Values Tools">addMethod: source for: target in: protocol package: aPackageModel	"&lt;AddMethodChange | nil&gt;"	| pretty change |	(target needs: source) ifFalse: [		^nil].	pretty := (Refactory.Browser.RBParser parseMethod: source) formattedCode.	change := Refactory.Browser.AddMethodChange compile: pretty in: target classified: protocol.	change package: aPackageModel.	^change</body><body package="Values Tools">addMethodNamed: selector for: target in: protocol	"&lt;AddMethodChange | nil&gt;"	^self addMethod: (self asMethodSourceNamed: selector) for: target in: protocol</body><body package="Values Tools">addMethodNamed: selector for: aMetaClass in: protocol package: aPackageModel	"&lt;AddMethodChange | nil&gt;"	^self		addMethod: (self asMethodSourceFor: aMetaClass named: selector)		for: aMetaClass		in: protocol		package: aPackageModel</body><body package="Values Tools">asMethodSourceFor: aMetaClass named: selector	| wst |	wst := WriteStream on: (String new: 200).	wst		nextPutAll: selector;		crtab;		nextPut: $^;		nextPutAll: (self asSourceFor: aMetaClass soleInstance).	^wst contents</body><body package="Values Tools">asMethodSourceNamed: selector	| wst |	wst := WriteStream on: (String new: 200).	wst		nextPutAll: selector;		crtab;		nextPut: $^;		nextPutAll: self asSource.	^wst contents</body><body package="Values Tools">betterTestInstanceThan: aValue	"&lt;Boolean&gt;	true, iff the receiver is better as a test instance than aValue"	^true</body><body package="Values Tools">isBetterTestInstanceSelector: aSymbol	(self class respondsTo: aSymbol) ifFalse: [		^true].	^self betterTestInstanceThan: (self class perform: aSymbol)</body><body package="Values Tools">isUsefulTestInstance	^self notEmpty</body><body package="Values Tools">methodProtocol	^#'test instances'</body><body package="Values Tools">newSelectorBasedOn: aString	"&lt;Symbol | nil&gt;	return a new selector by adding '_&lt;Integer&gt;' to the base selector"	| selector count |	selector := aString asSymbol.	count := 1.	[self class respondsTo: selector] whileTrue: [		selector := (aString , '_' , count printString) asSymbol.		count := count + 1].	^selector</body><body package="Values Tools">selectorString	"&lt;String&gt;"	"if this object should be savable, implement this method to return a suitable unique string"	^'example', self class name asString</body></methods><methods><class-id>Value</class-id> <category>user interface</category><body package="Values Tools">inspectorActions	^Array with: (Tools.Trippy.Action label: 'Save as method...' block: [		self addAsMethod			ifNotNil: [:assoc |			| md |			md := MethodDefinition class: assoc key selector: assoc value.			MethodCollector new				openListBrowserOn: (Array with: md)				label: 'Generated Method'				initialSelection: nil]			ifNil: [			self halt]])</body></methods><methods><class-id>Value class</class-id> <category>class initialization</category><body package="Values">obsolete	self allInstancesDo: #beMutable.	super obsolete</body></methods><methods><class-id>Value class</class-id> <category>named values</category><body package="Values">namedValuesAt: aClass	"&lt;Dictionary key: Value value: Symbol&gt;	the named instances of aClass"	^self namedValuesRegistry at: aClass ifAbsent: [Dictionary new]</body><body package="Values">namedValuesAt: aClass ifAbsentPut: aBlock	"&lt;Dictionary key: Value value: Symbol&gt;	the named instances of aClass"	^self namedValuesRegistry at: aClass ifAbsentPut: aBlock</body><body package="Values">namedValuesRegistry	"&lt;Dictionary key: Class value: (Dictionary key: Value value: Symbol)&gt;	the named instances of classes.	This is a light weight implementation to hold all named instances of all classes, instead of storing them with the class"		^NamedValuesRegistry ifNil: [NamedValuesRegistry := Valuemap new]</body></methods><methods><class-id>Value class</class-id> <category>initialize-release</category><body package="Values">primeRuntime	"reset and load all class variables to fill the caches to avoid lazy initialization at runtime.	This should be executed when deploying after all application fonts and extensions are loaded"	"self primeRuntime"	self resetNamedValuesRegistry.	Object namesByValues</body><body package="Values">resetNamedValuesRegistry	"self resetNamedValuesRegistry"	NamedValuesRegistry := nil</body></methods><methods><class-id>Value class</class-id> <category>specification</category><body package="Values">localSpecification	"specification of the constants with pragmas.	Only for the instvars defined in this class - access the full specification with #specification"	^self subclassResponsibility</body><body package="Values Tools">specification	"&lt;ValueSpecification&gt;"	"the comprehensive specification of the constants of this class"	| constants superclasses |	constants := OrderedCollection new.	superclasses := self withAllSuperclasses reverse.	"from superclasses to subclasses"	superclasses remove: Object.	superclasses remove: Value.	superclasses do: [:aSuperclass |		(aSuperclass class includesSelector: #localSpecification) ifTrue: [			| pragmas consts |			pragmas := Pragma allInMethod: (aSuperclass class compiledMethodAt: #localSpecification).			consts := pragmas collect: [:pragma | Value perform: pragma keyword withArguments: pragma arguments].			consts do: [:constant |				(constants detect: [:c | c name = constant name] ifNone: [nil]) ifNotNil: [:c |					constants remove: c	"subclasses overwrite superclass specifications"].				constants add: constant]]].	^ValueSpecification constants: constants</body></methods><methods><class-id>Value class</class-id> <category>pragmas</category><body package="Values Tools">constant: aSymbol class: aLiteralBindingReference	^ConstantSpecification selector: aSymbol type: aLiteralBindingReference</body><body package="Values Tools">constant: aSymbol class: aLiteralBindingReference comment: commentString	^ConstantSpecification		selector: aSymbol		comment: commentString		type: aLiteralBindingReference</body><body package="Values Tools">map: aSymbol	^DictionarySpecification selector: aSymbol</body><body package="Values Tools">map: aSymbol comment: commentString	^DictionarySpecification selector: aSymbol comment: commentString</body><body package="Values Tools">optional: aSymbol class: aLiteralBindingReference default: aString	^OptionalConstantSpecification selector: aSymbol type: aLiteralBindingReference default: aString</body><body package="Values Tools">optional: aSymbol class: aLiteralBindingReference default: aString comment: commentString	^OptionalConstantSpecification		selector: aSymbol		comment: commentString		type: aLiteralBindingReference		default: aString</body><body package="Values Tools">sequence: aSymbol	^ArraySpecification selector: aSymbol</body><body package="Values Tools">sequence: aSymbol comment: commentString	^ArraySpecification selector: aSymbol comment: commentString</body></methods><methods><class-id>Value class</class-id> <category>source generation</category><body package="Values Tools">differentPrintMethods	"self differentPrintMethods"	"construct change objects for all printers with different source code than generated"	| change |	change := Refactory.Browser.CompositeRefactoryChange named: 'Different print methods in subclasses of ' , self name asString.	self subclassesWithConstants do: [:aClass |		(aClass specification sourcePrintvalueWithFor: aClass) ifNotNil: [:aRefactoryChangeOrNil |			change addChange: aRefactoryChangeOrNil]].	change changes isEmpty ifTrue: [		^Dialog warn: 'No changes'].	change inspect</body><body package="Values Tools">generateMethods	"construct change objects and opens the list for the user to execute"	| change |	(self hasSpecification not and: [	self isLeafClass not]) ifTrue: [			^Dialog warn: 'no specification found and abstract'].	change := Refactory.Browser.CompositeRefactoryChange named: 'Create value methods for ' , self name asString.	self specification addMethodsFor: self to: change.	change changes isEmpty ifTrue: [		^Dialog warn: 'No changes'].	change inspect</body></methods><methods><class-id>Value class</class-id> <category>conformance testing</category><body package="Values Tools">allLeafClassesHaveEmptyInstance	"tests that #asSource and #= are implemented"	"self allLeafClassesHaveEmptyInstance"	| nonConforming |	nonConforming := Value leafClasses reject: [:class |		class new asSource = (class name asString , ' new')].	nonConforming notEmpty ifTrue: [		^self error: 'some classes do not conform to the Value protocol'].	^true</body><body package="Values Tools">allLeafClassesHaveWorkingExample	"tests that #example is implemented and works"	"self allLeafClassesHaveWorkingExample"	| nonConforming |	nonConforming := Value leafClasses reject: [:class |		(((class class includesSelector: #localSpecification) and: [		class class includesSelector: #example]) or: [			true]) and: [			class example asSource = (class evaluate: (class example asSourceFor: class)) asSource]].	nonConforming notEmpty ifTrue: [		^self error: 'some classes do not conform to the Value protocol'].	^true</body><body package="Values Tools">allValuesHavePrinters	"tests that #printvalueWith: is implemented when there is state"	"self allValuesHavePrinters"	| nonConforming |	nonConforming := Value subclassesWithConstants reject: [:class |		class includesSelector: ValueSpecification printSelector].	nonConforming notEmpty ifTrue: [		^self error: 'some classes do not conform to the Value protocol'].	^true</body></methods><methods><class-id>Value class</class-id> <category>test instances</category><body package="Values Tools">example	"&lt;Value&gt;"	^self new</body><body package="Values Tools">literalExample	^self example</body></methods><methods><class-id>Value class</class-id> <category>accessing class hierarchy</category><body package="Values Tools">leafClasses	^self allSubclasses select: [:subclass | subclass isLeafClass]</body><body package="Values Tools">subclassesWithConstants	^Value allSubclasses select: [:aClass | aClass instVarNames notEmpty]</body></methods><methods><class-id>Value class</class-id> <category>compiling</category><body package="Values Tools">evaluate: source	^self compilerClass		evaluate: source		for: self		in: self environment		notifying: nil		logged: false</body></methods><methods><class-id>Value class</class-id> <category>accessing</category><body package="Values Tools">toolListIcon	^ListIconLibrary visualFor: #value</body></methods><methods><class-id>Value class</class-id> <category>testing</category><body package="Values Tools">hasSpecification	^self class includesSelector: #localSpecification</body></methods><methods><class-id>Value class</class-id> <category>testing class hierarchy</category><body package="Values Tools">isLeafClass	^self subclasses isEmpty</body></methods><methods><class-id>Emitter</class-id> <category>accessing</category><body package="Values">emitterClassFor: printvalue	"&lt;Emitter class&gt;"	^self subclassResponsibility</body><body package="Values">emitterFor: printvalue	"&lt;Emitter&gt;"	^(self emitterClassFor: printvalue) for: self printer on: self stream at: self level</body><body package="Values">level	"&lt;Integer&gt;	the indent level"	^level ifNil: [0]</body><body package="Values">newStream	^self streamClass on: (String new: 100)</body><body package="Values">printer	"&lt;ValuePrinter&gt;"	^printer</body><body package="Values">stream	"&lt;WriteStream | TextStream&gt;	the output stream"	^stream ifNil: [stream := self newStream]</body><body package="Values">streamClass	"&lt;WriteStream class | TextStream class&gt;"	^self subclassResponsibility</body></methods><methods><class-id>Emitter</class-id> <category>writing</category><body package="Values">emit: aString	self stream nextPutAll: aString</body><body package="Values">emitArgument: aPrintargument	self emit: aPrintargument name , ': '.	aPrintargument value sourceFor: self</body><body package="Values">emitArraySourceFor: anArray	self inBracketsDo: [		anArray size &gt; 4			ifTrue: [self emitLongCollection: anArray]			ifFalse: [			self emitSmallCollection: anArray]]</body><body package="Values">emitClass: aString	self emit: aString</body><body package="Values">emitDictionarySourceFor: aDictionaryPrintvalue	self inBracketsDo: [		aDictionaryPrintvalue arguments size &gt; 4			ifTrue: [			self emitLongDictionary: aDictionaryPrintvalue]			ifFalse: [			self emitSmallDictionary: aDictionaryPrintvalue]]</body><body package="Values">emitEmpty: aValuePrintvalue	"write the constructor for an empty instance"	self emitClass: aValuePrintvalue classname.	self emit: ' new'</body><body package="Values">emitLongCollection: aSequenceableCollection	self emit: '(', (OrderedCollection nameRelativeTo: self printer target) , ' new: ' , aSequenceableCollection size printString, ')'.	aSequenceableCollection do: [:value |		self emitSeparator.		self emit: 'add: '.		value sourceFor: self.		self stream nextPut: $;].	self emitSeparator.	self emit: 'yourself'</body><body package="Values">emitLongDictionary: aDictionaryPrintvalue	self emit: '(', (aDictionaryPrintvalue targetClass nameRelativeTo: self printer target), ' new: ' , aDictionaryPrintvalue arguments size printString, ')'.	aDictionaryPrintvalue arguments do: [:argument |		self emitSeparator.		self emit: 'add: '.		argument name sourceFor: self.		self emit: ' -&gt; '.		argument value sourceFor: self.		self stream nextPut: $;].	self emitSeparator.	self emit: 'yourself'</body><body package="Values">emitSeparator	self subclassResponsibility</body><body package="Values">emitSmallCollection: aSequenceableCollection	self emit: (Array nameRelativeTo: self printer target).	aSequenceableCollection do: [:value |		self emitSeparator.		self emit: 'with: '.		value sourceFor: self]</body><body package="Values">emitSmallDictionary: aDictionaryPrintvalue	self emit: (aDictionaryPrintvalue targetClass nameRelativeTo: self printer target).	aDictionaryPrintvalue arguments do: [:argument |		self emitSeparator.		self emit: 'with: '.		argument name sourceFor: self.		self emit: ' -&gt; '.		argument value sourceFor: self]</body><body package="Values">emitValue: aString	self emit: aString</body><body package="Values">inBracketsDo: aZeroArgumentBlock	self stream nextPut: $(.	aZeroArgumentBlock ensure: [self stream nextPut: $)]</body></methods><methods><class-id>Emitter</class-id> <category>initialize-release</category><body package="Values">initializePrinter: aPrinter stream: aWriteStream level: anInteger	printer := aPrinter.	stream := aWriteStream.	level := anInteger</body></methods><methods><class-id>Emitter class</class-id> <category>instance creation</category><body package="Values">for: aPrinter	| inst |	inst := self new.	inst initializePrinter: aPrinter stream: nil level: -1.	^inst</body><body package="Values">for: aPrinter on: aWriteStream at: anInteger	| inst |	inst := self new.	inst initializePrinter: aPrinter stream: aWriteStream level: anInteger.	^inst</body></methods><methods><class-id>Core.Valuemap</class-id> <category>private</category><body package="Values">atNewIndex: index put: anAssociation	self basicAt: index put: anAssociation.	tally := tally + 1.	self order addLast: anAssociation key.	self fullCheck</body><body package="Values">noCheckAdd: anAssociation	super noCheckAdd: anAssociation.	self order addLast: anAssociation key</body><body package="Values">setTally	super setTally.	order := nil</body></methods><methods><class-id>Core.Valuemap</class-id> <category>accessing</category><body package="Values">atIndex: index	"&lt;Association&gt;"	^self associationAt: (self order at: index)</body><body package="Values">first	"&lt;Association&gt;"	^self associationAt: self keys first</body><body package="Values">indexOf: aKey	"&lt;Integer&gt;"	^self order indexOf: aKey</body><body package="Values">keys	"&lt;SequenceableCollection of: Object&gt;"	^self order copy</body><body package="Values">last	"&lt;Association&gt;"	^self associationAt: self keys last</body><body package="Values">order	"&lt;SequenceableCollection of: Object&gt;	the order of the keys"	^order ifNil: [order := OrderedCollection new]</body></methods><methods><class-id>Core.Valuemap</class-id> <category>enumerating</category><body package="Values">collect: oneArgumentBlock	| newCollection |	newCollection := self species new: self size.	self keysAndValuesDo: [:eachKey :eachValue | 		newCollection at: eachKey put: (oneArgumentBlock value: eachValue)].	^newCollection</body><body package="Values">do: oneArgumentBlock	self order do: [:key |		oneArgumentBlock value: (self at: key)]</body><body package="Values">keysAndValuesDo: oneArgumentBlock	self order do: [:key |		oneArgumentBlock value: key value: (self at: key)]</body></methods><methods><class-id>Core.Valuemap</class-id> <category>comparing</category><body package="Values">= otherOrderedDictionary	^self class == otherOrderedDictionary class and: [	self size = otherOrderedDictionary size and: [	(1 to: self size) allSatisfy: [:i |		(self atIndex: i) = (otherOrderedDictionary atIndex: i)]]]</body><body package="Values">hash	^(1 to: self size) inject: self class hash into: [:hash :index |		| assoc |		assoc := self atIndex: index.		hash bitXor: (assoc key hash bitXor: assoc value hash)]</body></methods><methods><class-id>Core.Valuemap</class-id> <category>printing</category><body package="Values Tools">describeOn: textStream	textStream nextPutAllText: self class name asString asText allBold.	textStream nextPutAll: ' new'.	self keysAndValuesDo: [:key :value |		textStream			cr;			tab;			nextPutAll: 'at: ' , key printString , ' put: '.		textStream nextPutAllText: value printString asText allBold.		textStream nextPut: $;].	textStream		cr;		tab;		nextPutAll: 'yourself'</body><body package="Values Tools">descriptionText	"&lt;Text&gt;	nicely formated for the user"	| wst |	wst := TextStream on: (String new: 200).	self describeOn: wst.	^wst contents</body><body package="Values">keysForPrinting	^self keys</body><body package="Values">printvalueWith: printer	^DictionaryPrintvalue arguments: (self printargumentsWith: printer) isOrdered: true</body></methods><methods><class-id>Core.Valuemap</class-id> <category>copying</category><body package="Values">copyWith: anAssociation 	"Answer a copy of the receiver with anAssociation added"	| copy |	copy := self copy.	copy add: anAssociation.	^copy</body><body package="Values">copyWithAll: aDictionary	"Answer a copy of the receiver with all associations from aDictionary added"	| copy |	copy := self copy.	copy addAll: aDictionary.	^copy</body><body package="Values">postCopy	super postCopy.	order := self order copy</body></methods><methods><class-id>Core.Valuemap</class-id> <category>dictionary enumerating</category><body package="Values">associationsDo: aBlock	"Note: do not use the keys to access anything.	This method is used by #changeCapacityTo: and #rehash where key access is not working"	| assocs |	assocs := Array new: self order size.	super associationsDo: [:assoc | assocs at: (self order indexOf: assoc key) put: assoc].	assocs do: aBlock</body></methods><methods><class-id>Core.Valuemap</class-id> <category>dictionary removing</category><body package="Values">removeKey: key ifAbsent: aBlock	| index element |	index := self findKey: key ifAbsent: nil.	"avoid full block"	index isNil ifTrue: [		^aBlock value].	element := self basicAt: index.	self order remove: element key.	self basicAt: index put: nil.	tally := tally - 1.	self fixCollisionsFrom: index.	^element value</body></methods><methods><class-id>Core.Valuemap</class-id> <category>dictionary testing</category><body package="Values">isEqualValue: anObject	^self = anObject</body></methods><methods><class-id>Core.Valuemap</class-id> <category>user interface</category><body package="Values Tools">inspectorClasses	^Array		with: Tools.Trippy.ValuemapInspector		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>Core.Valuemap class</class-id> <category>test instances</category><body package="Values Testing">example	"self example"	| map |	map := Valuemap new.	map at: #title put: self class name , ' example with examples of all basic values'.	map at: #boolean put: true.	map at: #character put: $A.	map at: #symbol put: #mySymbol.	map at: #string put: 'with umlauts and euro: äöüß€'.	map at: #schlüssel put: nil.	map at: #integer put: 42.	map at: #number put: 3.14.	map at: #date put: (Date d: 27 m: 3 y: 2022).	map at: #time put: (Time h: 12 m: 18).	map at: #timestamp put: (Timestamp d: 27 m: 3 y: 2022 h: 12 m: 18).	map at: #duration put: 5 minutes.	map at: #color put: (ColorValue fromBytesRed: 127 green: 0 blue: 0).	map at: #knownColor put: ColorValue red.	map at: #array put: #(#one 'two' 3).	map at: #bytearray put: #[1 2 3].	map		at: #valuemap		put: (Valuemap			with: #test -&gt; true			with: #two -&gt; 2			with: #none -&gt; nil).	^map</body></methods><methods><class-id>ValuePrinter</class-id> <category>accessing</category><body package="Values">array: selectorname value: object	"&lt;Printargument | nil&gt;"	object isEmpty ifTrue: [		^nil].	^Printargument name: selectorname value: (object printvalueWith: self)</body><body package="Values">classnameOf: value	^value class nameRelativeTo: self target</body><body package="Values">constant: selectorname value: object	"&lt;Printargument&gt;"	^Printargument name: selectorname value: (object printvalueWith: self)</body><body package="Values">dictionary: selectorname value: object	"&lt;Printargument | nil&gt;"	object isEmpty ifTrue: [		^nil].	^Printargument name: selectorname value: (object printvalueWith: self)</body><body package="Values">optional: selectorname value: object	"&lt;Printargument | nil&gt;"	^object ifNotNil: [		Printargument name: selectorname value: (object printvalueWith: self)]</body><body package="Values">printvalue: aValue arguments: arguments	aValue class new = aValue ifTrue: [		^ValuePrintvalue classname: (self classnameOf: aValue)].	^ValuePrintvalue		classname: (self classnameOf: aValue)		arguments: (arguments select: [:arg |			arg notNil])</body><body package="Values">target	"&lt;Value class&gt;	the class for which the object is printed as if the generated source is included into a method of the class.	Takes the visibility of classes into account for class name generation (with or without namespaces)"	^target</body></methods><methods><class-id>ValuePrinter</class-id> <category>initialize-release</category><body package="Values">initializeTarget: targetClass	target := targetClass</body></methods><methods><class-id>ValuePrinter class</class-id> <category>instance creation</category><body package="Values">newFor: targetClass	| inst |	inst := self new.	inst initializeTarget: targetClass.	^inst</body></methods><methods><class-id>Printargument</class-id> <category>initialize-release</category><body package="Values">initializeName: nameString value: valuePrintvalue	name := nameString.	value := valuePrintvalue.	self beImmutable</body></methods><methods><class-id>Printargument</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'name' value: self name).	args add: (printer constant: 'value' value: self value).	^printer printvalue: self arguments: args</body></methods><methods><class-id>Printargument</class-id> <category>accessing</category><body package="Values">name	"&lt;String&gt;"	^name</body><body package="Values">sourceWith: emitter	emitter emitArgument: self</body><body package="Values">value	"&lt;Printvalue&gt;"	^value</body></methods><methods><class-id>Printargument</class-id> <category>testing</category><body package="Values">isSimple	^self value isSimple</body></methods><methods><class-id>Printargument class</class-id> <category>instance creation</category><body package="Values">name: nameString value: valuePrintvalue	| inst |	inst := self new.	inst initializeName: nameString value: valuePrintvalue.	^inst</body></methods><methods><class-id>Printargument class</class-id> <category>test instances</category><body package="Values Tools">example	^Printargument		name: 'constant'		value: (ValuePrintvalue			classname: 'ConstantSpecification'			arguments: (Array				with: (Printargument name: 'selector' value: '#value')				with: (Printargument name: 'type' value: '#{Number}')))</body></methods><methods><class-id>Printvalue</class-id> <category>testing</category><body package="Values">isLine	^false</body><body package="Values">isSimple	"does it have to be printed in brackets?	only literals are simple"	^false</body></methods><methods><class-id>Printvalue</class-id> <category>accessing</category><body package="Values">description	"&lt;Text&gt;"	| emitter |	emitter := self textemitterClass new.	self sourceWith: emitter.	^emitter stream contents</body><body package="Values">emitterClass	"&lt;SourceEmitter class&gt;"	^self isLine		ifTrue: [LineEmitter]		ifFalse: [BlockEmitter]</body><body package="Values">sourceFor: outerEmitter	"&lt;String&gt;"	^self sourceWith: (outerEmitter emitterFor: self)</body><body package="Values">sourceWith: emitter	"write yourself with the emitter"	^self subclassResponsibility</body><body package="Values">sourceWithPrinter: aPrinter	"&lt;String&gt;"	| emitter |	emitter := self emitterClass for: aPrinter.	self sourceWith: emitter.	^emitter stream contents</body><body package="Values">textemitterClass	"&lt;SourceEmitter class&gt;"	^self isLine		ifTrue: [TextLineEmitter]		ifFalse: [TextBlockEmitter]</body></methods><methods><class-id>SourceEmitter</class-id> <category>accessing</category><body package="Values">emitterClassFor: printvalue	^printvalue isLine		ifTrue: [LineEmitter]		ifFalse: [BlockEmitter]</body><body package="Values">streamClass	^WriteStream</body></methods><methods><class-id>TextEmitter</class-id> <category>writing</category><body package="Values">emitArraySourceFor: anArray	self emitSmallCollection: anArray</body><body package="Values">emitBold: aString	self stream nextPutAllText: aString asText allBold</body><body package="Values">emitClass: aString	self emitBold: aString</body><body package="Values">emitDictionarySourceFor: aDictionaryPrintvalue	self emitSmallDictionary: aDictionaryPrintvalue</body><body package="Values">emitSmallCollection: aSequenceableCollection	aSequenceableCollection do: [:value |		self emitSeparator.		value sourceFor: self]</body><body package="Values">emitSmallDictionary: aDictionaryPrintvalue	aDictionaryPrintvalue arguments do: [:argument |		self emitSeparator.		argument name sourceFor: self.		self emit: ': '.		argument value sourceFor: self]</body><body package="Values">emitValue: aString	self emitBold: aString</body></methods><methods><class-id>TextEmitter</class-id> <category>accessing</category><body package="Values">emitterClassFor: printvalue	^printvalue isLine		ifTrue: [TextLineEmitter]		ifFalse: [TextBlockEmitter]</body><body package="Values">streamClass	^TextStream</body></methods><methods><class-id>DictionaryPrintargument class</class-id> <category>test instances</category><body package="Values Tools">example	^DictionaryPrintargument name: Printvalue new value: Printvalue new</body></methods><methods><class-id>ValuePrintvalue</class-id> <category>accessing</category><body package="Values">arguments	"&lt;Array&gt;"	^arguments ifNil: [#()]</body><body package="Values">classname	"&lt;String&gt;"	^classname</body><body package="Values">sourceWith: emitter	self arguments isEmpty ifTrue: [		^emitter emitEmpty: self].	emitter inBracketsDo: [		emitter emitClass: self classname.		self arguments do: [:arg |			emitter emitSeparator.			emitter emitArgument: arg]]</body></methods><methods><class-id>ValuePrintvalue</class-id> <category>initialize-release</category><body package="Values">initializeClassname: classnameString arguments: argumentsArray	classname := classnameString.	(argumentsArray notNil and: [	argumentsArray notEmpty]) ifTrue: [			arguments := (Array withAll: argumentsArray) beImmutable].	self beImmutable</body></methods><methods><class-id>ValuePrintvalue</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'classname' value: self classname).	args add: (printer array: 'arguments' value: self arguments).	^printer printvalue: self arguments: args</body></methods><methods><class-id>ValuePrintvalue</class-id> <category>testing</category><body package="Values">isLine	self arguments size = 1 ifTrue: [		^self arguments first value isLine].	^self arguments size &lt; 5 and: [	self arguments allSatisfy: [:arg | arg isSimple]]</body></methods><methods><class-id>ValuePrintvalue class</class-id> <category>instance creation</category><body package="Values">classname: classnameString arguments: argumentsArray	| inst |	inst := self new.	inst initializeClassname: classnameString arguments: argumentsArray.	^inst</body></methods><methods><class-id>ValuePrintvalue class</class-id> <category>instance creation optional</category><body package="Values">classname: classnameString	^self classname: classnameString arguments: nil</body></methods><methods><class-id>ValuePrintvalue class</class-id> <category>test instances</category><body package="Values Tools">example	^ValuePrintvalue		classname: 'ConstantSpecification'		arguments: (Array			with: (Printargument name: 'selector' value: '#value')			with: (Printargument name: 'type' value: '#{Number}'))</body></methods><methods><class-id>LineEmitter</class-id> <category>writing</category><body package="Values">emitSeparator	self stream space</body></methods><methods><class-id>ArrayPrintvalue</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer array: 'arguments' value: self arguments).	^printer printvalue: self arguments: args</body></methods><methods><class-id>ArrayPrintvalue</class-id> <category>accessing</category><body package="Values">arguments	"&lt;Array&gt;"	^arguments ifNil: [#()]</body><body package="Values">sourceWith: emitter	emitter emitArraySourceFor: self arguments</body></methods><methods><class-id>ArrayPrintvalue</class-id> <category>testing</category><body package="Values">isLine	^self arguments size = 1 or: [	self arguments size &lt; 5 and: [	self arguments allSatisfy: [:arg | arg isSimple]]]</body></methods><methods><class-id>ArrayPrintvalue</class-id> <category>initialize-release</category><body package="Values">initializeArguments: argumentsArray	(argumentsArray notNil and: [	argumentsArray notEmpty]) ifTrue: [			arguments := (Array withAll: argumentsArray) beImmutable].	self beImmutable</body></methods><methods><class-id>ArrayPrintvalue class</class-id> <category>instance creation</category><body package="Values">arguments: argumentsArray	| inst |	inst := self new.	inst initializeArguments: argumentsArray.	^inst</body></methods><methods><class-id>ArrayPrintvalue class</class-id> <category>test instances</category><body package="Values Tools">example	^ArrayPrintvalue arguments: (Array		with: (Printargument name: 'selector' value: '#value')		with: (Printargument name: 'type' value: '#{Number}'))</body></methods><methods><class-id>BlockEmitter</class-id> <category>initialize-release</category><body package="Values">initializePrinter: aPrinter stream: aWriteStream level: anInteger	printer := aPrinter.	stream := aWriteStream.	level := anInteger + 1</body></methods><methods><class-id>BlockEmitter</class-id> <category>writing</category><body package="Values">emitSeparator	self stream cr.	self level + 1 timesRepeat: [self stream tab]</body></methods><methods><class-id>LiteralPrintvalue</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'string' value: self string).	^printer printvalue: self arguments: args</body></methods><methods><class-id>LiteralPrintvalue</class-id> <category>accessing</category><body package="Values">sourceWith: emitter	emitter emitValue: self string</body><body package="Values">string	"&lt;String&gt;"	^string</body></methods><methods><class-id>LiteralPrintvalue</class-id> <category>testing</category><body package="Values">isLine	^true</body><body package="Values">isSimple	^(self string first = $() not</body></methods><methods><class-id>LiteralPrintvalue</class-id> <category>initialize-release</category><body package="Values">initializeString: stringString	string := stringString.	self beImmutable</body></methods><methods><class-id>LiteralPrintvalue class</class-id> <category>instance creation</category><body package="Values">string: stringString	| inst |	inst := self new.	inst initializeString: stringString.	^inst</body></methods><methods><class-id>LiteralPrintvalue class</class-id> <category>test instances</category><body package="Values Tools">example	^LiteralPrintvalue string: '(Date d: 8 m: 7 y: 2007)'</body></methods><methods><class-id>TextBlockEmitter</class-id> <category>initialize-release</category><body package="Values">initializePrinter: aPrinter stream: aWriteStream level: anInteger	printer := aPrinter.	stream := aWriteStream.	level := anInteger + 1</body></methods><methods><class-id>TextBlockEmitter</class-id> <category>writing</category><body package="Values">emitSeparator	self stream cr.	self level + 1 timesRepeat: [self stream tab]</body><body package="Values">inBracketsDo: aZeroArgumentBlock	aZeroArgumentBlock value</body></methods><methods><class-id>DictionaryPrintvalue</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer array: 'arguments' value: self arguments).	args add: (printer optional: 'isOrdered' value: isOrdered).	^printer printvalue: self arguments: args</body></methods><methods><class-id>DictionaryPrintvalue</class-id> <category>accessing</category><body package="Values">arguments	"&lt;Array&gt;"	^arguments ifNil: [#()]</body><body package="Values">isOrdered	"&lt;Boolean&gt;"	^isOrdered ifNil: [false]</body><body package="Values">sourceWith: emitter	self isEmpty ifTrue: [		^emitter emit: self targetClassname , ' new'].	emitter emitDictionarySourceFor: self</body><body package="Values">targetClass	^self isOrdered		ifTrue: [Valuemap]		ifFalse: [Dictionary]</body><body package="Values">targetClassname	^self targetClass name asString</body></methods><methods><class-id>DictionaryPrintvalue</class-id> <category>testing</category><body package="Values">isEmpty	^self arguments isEmpty</body><body package="Values">isLine	^self isEmpty</body></methods><methods><class-id>DictionaryPrintvalue</class-id> <category>initialize-release</category><body package="Values">initializeArguments: argumentsArray isOrdered: isOrderedBoolean	(argumentsArray notNil and: [	argumentsArray notEmpty]) ifTrue: [			arguments := (Array withAll: argumentsArray) beImmutable].	(isOrderedBoolean notNil and: [	self isOrdered ~= isOrderedBoolean]) ifTrue: [			isOrdered := isOrderedBoolean].	self beImmutable</body></methods><methods><class-id>DictionaryPrintvalue class</class-id> <category>instance creation</category><body package="Values">arguments: argumentsArray isOrdered: isOrderedBoolean	| inst |	inst := self new.	inst initializeArguments: argumentsArray isOrdered: isOrderedBoolean.	^inst</body></methods><methods><class-id>DictionaryPrintvalue class</class-id> <category>instance creation optional</category><body package="Values">arguments: argumentsArray	^self arguments: argumentsArray isOrdered: nil</body><body package="Values">isOrdered: isOrderedBoolean	^self arguments: nil isOrdered: isOrderedBoolean</body></methods><methods><class-id>DictionaryPrintvalue class</class-id> <category>test instances</category><body package="Values Tools">example	^DictionaryPrintvalue arguments: (Array		with: (DictionaryPrintargument			name: (LiteralPrintvalue string: '123')			value: (LiteralPrintvalue string: '#value'))		with: (DictionaryPrintargument			name: (LiteralPrintvalue string: '#other')			value: (LiteralPrintvalue string: '#{Number}')))</body></methods><methods><class-id>TextLineEmitter</class-id> <category>writing</category><body package="Values">emitSeparator	self stream space</body></methods><methods><class-id>ValueTest</class-id> <category>testing</category><body package="Values Testing">testIsEmpty	self		assert: Value new isEmpty;		deny: Value new notEmpty</body><body package="Values Testing">testIsEqualValue	self		assert: (1 isEqualValue: 1);		assert: (1 isEqualValue: 1.0);		assert: (ColorValue red isEqualValue: (ColorValue fromBytesRed: 255 green: 0 blue: 0));		assert: ((Dictionary with: #a -&gt; $a with: #b -&gt; $b) isEqualValue: (Dictionary with: #b -&gt; $b with: #a -&gt; $a));		deny: ((Valuemap with: #a -&gt; $a with: #b -&gt; $b) isEqualValue: (Valuemap with: #b -&gt; $b with: #a -&gt; $a))</body></methods><methods><class-id>Testvalue</class-id> <category>accessing</category><body package="Values Testing">array	"&lt;Array&gt;"	^array ifNil: [#()]</body><body package="Values Testing">constant	"&lt;Symbol&gt;"	^constant</body><body package="Values Testing">dictionary	"&lt;Dictionary&gt;"	^dictionary ifNil: [Dictionary new beImmutable]</body><body package="Values Testing">optional	"&lt;Symbol&gt;"	^optional ifNil: [#none]</body></methods><methods><class-id>Testvalue</class-id> <category>printing</category><body package="Values Testing">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'constant' value: self constant).	args add: (printer optional: 'optional' value: optional).	args add: (printer array: 'array' value: self array).	args add: (printer dictionary: 'dictionary' value: self dictionary).	^printer printvalue: self arguments: args</body></methods><methods><class-id>Testvalue</class-id> <category>marshaling</category><body package="Values Testing">passInstVars	"for OpenTalk StSt"	^#(#default #default #default #value)</body></methods><methods><class-id>Testvalue</class-id> <category>initialize-release</category><body package="Values Testing">initializeConstant: constantSymbol optional: optionalSymbol array: arrayArray dictionary: dictionaryDictionary	constant := constantSymbol.	(optionalSymbol notNil and: [	self optional ~= optionalSymbol]) ifTrue: [			optional := optionalSymbol].	(arrayArray notNil and: [	arrayArray notEmpty]) ifTrue: [			array := (Array withAll: arrayArray) beImmutable].	(dictionaryDictionary notNil and: [	dictionaryDictionary notEmpty]) ifTrue: [			dictionary := (Valuemap withAll: dictionaryDictionary) beImmutable].	self beImmutable</body></methods><methods><class-id>Testvalue class</class-id> <category>instance creation</category><body package="Values Testing">constant: constantSymbol optional: optionalSymbol array: arrayArray dictionary: dictionaryDictionary	| inst |	inst := self new.	inst		initializeConstant: constantSymbol		optional: optionalSymbol		array: arrayArray		dictionary: dictionaryDictionary.	^inst</body></methods><methods><class-id>Testvalue class</class-id> <category>instance creation optional</category><body package="Values Testing">constant: constantSymbol	| inst |	inst := self new.	inst initializeConstant: constantSymbol optional: nil array: nil dictionary: nil.	^inst</body><body package="Values Testing">constant: constantSymbol array: arrayArray	| inst |	inst := self new.	inst initializeConstant: constantSymbol optional: nil array: arrayArray dictionary: nil.	^inst</body><body package="Values Testing">constant: constantSymbol array: arrayArray dictionary: dictionaryDictionary	| inst |	inst := self new.	inst		initializeConstant: constantSymbol		optional: nil		array: arrayArray		dictionary: dictionaryDictionary.	^inst</body><body package="Values Testing">constant: constantSymbol dictionary: dictionaryDictionary	| inst |	inst := self new.	inst		initializeConstant: constantSymbol		optional: nil		array: nil		dictionary: dictionaryDictionary.	^inst</body><body package="Values Testing">constant: constantSymbol optional: optionalSymbol	| inst |	inst := self new.	inst initializeConstant: constantSymbol optional: optionalSymbol array: nil dictionary: nil.	^inst</body><body package="Values Testing">constant: constantSymbol optional: optionalSymbol array: arrayArray	| inst |	inst := self new.	inst		initializeConstant: constantSymbol		optional: optionalSymbol		array: arrayArray		dictionary: nil.	^inst</body><body package="Values Testing">constant: constantSymbol optional: optionalSymbol dictionary: dictionaryDictionary	| inst |	inst := self new.	inst		initializeConstant: constantSymbol		optional: optionalSymbol		array: nil		dictionary: dictionaryDictionary.	^inst</body></methods><methods><class-id>Testvalue class</class-id> <category>test instances</category><body package="Values Testing">example	^Testvalue		constant: #constantSymbol		optional: #optionalSymbol		array: #(1 #a $x 'name')		dictionary: (Valuemap			with: 1 -&gt; #symbol			with: #key -&gt; 'string')</body></methods><methods><class-id>ColorValueTest</class-id> <category>testing</category><body package="Values Testing">testAccessing	self		assert: ColorValue yellow yellow equals: 1.0;		assert: ColorValue cyan cyan equals: 1.0;		assert: ColorValue magenta magenta equals: 1.0</body><body package="Values Testing">testConversionToByteArray	self		assert: black asByteArray equals: #[0 0 0];		assert: white asByteArray equals: #[255 255 255]</body><body package="Values Testing">testConversionToColorValue	self		assert: black asColorValue == black;		assert: white asColorValue == white</body><body package="Values Testing">testConversionToColorValueFromColor	self		assert: black asColorValue equals: (ColorValue red: 0 green: 0 blue: 0);		assert: white asColorValue equals: (ColorValue red: 1 green: 1 blue: 1)</body><body package="Values Testing">testConversionToGrayValue	self		assert: black asGrayValue equals: 0.0;		assert: white asGrayValue equals: 1.0</body><body package="Values Testing">testNamedColors	self		assert: ColorValue namedValueNames size equals: 8;		assert: Object namedValueNames size equals: 0</body><body package="Values Testing">testNamesByValues	self assert: ColorValue namesByValues size equals: 8.	self assert: ColorValue namesByValues values asArray equals: ColorValue namedValueNames</body><body package="Values Testing">testRGBIndex	self		assert: black rgbIndex equals: 0;		assert: white rgbIndex equals: 2r111111111111111111111111</body></methods><methods><class-id>ColorValueTest</class-id> <category>running</category><body package="Values Testing">setUp	super setUp.	white := ColorValue white.	black := ColorValue black</body></methods><methods><class-id>ValuePrinterTest</class-id> <category>Testing</category><body package="Values Testing">testArray	self assert: Array new asSource equals: '#()'.	self assert: #(1 2 3 4) asSource equals: '#(1 2 3 4)'.	self assert: #(1 2 3 4 5 6 7 8 9 10) asSource equals: '#(1 2 3 4 5 6 7 8 9 10)'.	self		assert: (Array			with: 1			with: 2			with: 3			with: 4) asSource		equals: '#(1 2 3 4)'.	self		assert: (Array			with: 1			with: (Date d: 7 m: 7 y: 2007)			with: ColorValue red) asSource		equals: '(Array	with: 1	with: (Date d: 7 m: 7 y: 2007)	with: ColorValue red)'.	self		assert: (#(1 2 3 4) , (Array with: (Date d: 7 m: 7 y: 2007))) asSource		equals: '((OrderedCollection new: 5)	add: 1;	add: 2;	add: 3;	add: 4;	add: (Date d: 7 m: 7 y: 2007);	yourself)'.	self		assert: (Array			with: Testvalue example			with: (Date d: 7 m: 7 y: 2007)			with: ColorValue red) asSource		equals: '(Array	with: (Testvalue		constant: #constantSymbol		optional: #optionalSymbol		array: #(1 #a $x ''name'')		dictionary: (Valuemap			with: 1 -&gt; #symbol			with: #key -&gt; ''string''))	with: (Date d: 7 m: 7 y: 2007)	with: ColorValue red)'</body><body package="Values Testing">testArraySource	self		assert: (Testvalue			constant: #constantSymbol			optional: #optionalSymbol			array: #(1 #a $x 'name')			dictionary: (Valuemap				with: 1 -&gt; #symbol				with: #key -&gt; 'string')) asSource		equals: '(Testvalue	constant: #constantSymbol	optional: #optionalSymbol	array: #(1 #a $x ''name'')	dictionary: (Valuemap		with: 1 -&gt; #symbol		with: #key -&gt; ''string''))'</body><body package="Values Tools Testing">testArrayWithValue	self		assert: (Array with: ValueSpecification example) asSource		equals: '(Array with: (ValueSpecification	constants: (Array		with: (ConstantSpecification selector: #name comment: ''first there were names'' type: #{String})		with: (OptionalConstantSpecification selector: #default comment: ''if nothing is said'' type: #{String} default: ''String new'')		with: (ArraySpecification selector: #list comment: ''a list of things'')		with: (DictionarySpecification selector: #properties comment: ''The Properties''))))'</body><body package="Values Testing">testBoolean	self assert: true asSource equals: 'true'.	self assert: false asSource equals: 'false'</body><body package="Values Testing">testColorValue	self assert: ColorValue new isEmpty.	self assert: ColorValue red asSource equals: 'ColorValue red'.	self		assert: (ColorValue fromBytesRed: 0 green: 255 blue: 255) asSource		equals: 'ColorValue cyan'.	self		assert: (ColorValue fromBytesRed: 10 green: 255 blue: 255) asSource		equals: '(ColorValue fromBytesRed: 10 green: 255 blue: 255)'</body><body package="Values Testing">testDate	self assert: (Date d: 7 m: 7 y: 2007) asSource equals: '(Date d: 7 m: 7 y: 2007)'</body><body package="Values Testing">testDictionary	| dict |	self assert: Valuemap new asSource equals: 'Valuemap new'.	dict := Valuemap		with: 1 -&gt; 75		with: #b -&gt; $x.	self		assert: dict asSource		equals: '(Valuemap	with: 1 -&gt; 75	with: #b -&gt; $x)'</body><body package="Values Testing">testDictionarySource	self		assert: (Testvalue			constant: #constantSymbol			optional: #optionalSymbol			array: #(1 #a $x 'name')			dictionary: (Valuemap				with: 1 -&gt; #symbol				with: #key -&gt; 'string')) asSource		equals: '(Testvalue	constant: #constantSymbol	optional: #optionalSymbol	array: #(1 #a $x ''name'')	dictionary: (Valuemap		with: 1 -&gt; #symbol		with: #key -&gt; ''string''))'.	self assert: (Testvalue constant: #Haider) asSource equals: '(Testvalue constant: #Haider)'</body><body package="Values Testing">testDictionaryWithValues	| dict |	dict := Valuemap		with: 1 -&gt; Testvalue example		with: Testvalue example -&gt; $x.	self		assert: dict asSource		equals: '(Valuemap	with: 1 -&gt; (Testvalue		constant: #constantSymbol		optional: #optionalSymbol		array: #(1 #a $x ''name'')		dictionary: (Valuemap			with: 1 -&gt; #symbol			with: #key -&gt; ''string''))	with: (Testvalue		constant: #constantSymbol		optional: #optionalSymbol		array: #(1 #a $x ''name'')		dictionary: (Valuemap			with: 1 -&gt; #symbol			with: #key -&gt; ''string'')) -&gt; $x)'</body><body package="Values Testing">testDuration	self assert: 5 minutes asSource equals: '(Duration nanoseconds: 300000000000)'</body><body package="Values Testing">testEvaluateLongArray	self		shouldnt: [		(OrderedCollection new: 5)			add: 1;			add: 2;			add: 3;			add: 4;			add: (Date d: 7 m: 7 y: 2007);			yourself]		raise: Error</body><body package="Values Testing">testEvaluateLongDictionary	self		shouldnt: [		(Valuemap new: 6)			add: 1 -&gt; 75;			add: #b -&gt; $x;			add: 42 -&gt; 'Hello';			add: 'abc' -&gt; 32;			add: 2 -&gt; #(#String);			add: true -&gt; #hi;			yourself]		raise: Error</body><body package="Values Testing">testLiteralArrays	self assert: #(1 2 10 20 100) asSource equals: '#(1 2 10 20 100)'</body><body package="Values Testing">testLongDictionary	| dict |	dict := Valuemap new.	dict at: 1 put: 75.	dict at: #b put: $x.	dict at: 42 put: 'Hello'.	dict at: 'abc' put: 32.	dict at: 2 put: #(#String).	dict at: true put: #hi.	self		assert: dict asSource		equals: '((Valuemap new: 6)	add: 1 -&gt; 75;	add: #b -&gt; $x;	add: 42 -&gt; ''Hello'';	add: ''abc'' -&gt; 32;	add: 2 -&gt; #(#String);	add: true -&gt; #hi;	yourself)'</body><body package="Values Testing">testNumbers	self assert: 42 asSource equals: '42'.	self assert: 429999999939333 asSource equals: '429999999939333'.	self assert: 2.5 asSource equals: '2.5'	"only VW, not Gemstone	self assert: 2.5e7 asSource = '2.5e7'.	self assert: 2.5e-7 asSource = '2.5e-7'.	self assert: 2.5d137 asSource = '2.5d137'.	self assert: 2.5d-137 asSource = '2.5d-137'.	self assert: 25s7 asSource = '25.0000000s'.	self assert: (2 / 5) asSource = '(2 / 5)'.	"</body><body package="Values Testing">testOptionalConstantSource	self		assert: (Testvalue			constant: #constantSymbol			optional: #optionalSymbol			array: #(1 #a $x 'name')			dictionary: (Valuemap				with: 1 -&gt; #symbol				with: #key -&gt; 'string')) asSource		equals: '(Testvalue	constant: #constantSymbol	optional: #optionalSymbol	array: #(1 #a $x ''name'')	dictionary: (Valuemap		with: 1 -&gt; #symbol		with: #key -&gt; ''string''))'.	self		assert: (Testvalue			constant: #constantSymbol			optional: #optionalSymbol			array: #(1 #a $x 'name')) asSource		equals: '(Testvalue constant: #constantSymbol optional: #optionalSymbol array: #(1 #a $x ''name''))'.	self		assert: (Testvalue constant: #constantSymbol optional: #optionalSymbol) asSource		equals: '(Testvalue constant: #constantSymbol optional: #optionalSymbol)'.	self		assert: (Testvalue constant: #constantSymbol) asSource		equals: '(Testvalue constant: #constantSymbol)'</body><body package="Values Testing">testPoint	self assert: (1 @ 2) asSource equals: '1 @ 2'.	self assert: (1 @ (Date d: 7 m: 7 y: 2007)) asSource equals: '1 @ (Date d: 7 m: 7 y: 2007)'</body><body package="Values Testing">testTime	self assert: (Time h: 7 m: 27 s: 13) asSource equals: '(Time h: 7 m: 27 s: 13)'.	self assert: (Time h: 7 m: 27 s: 0) asSource equals: '(Time h: 7 m: 27)'.	self assert: (Time h: 7 m: 27) asSource equals: '(Time h: 7 m: 27)'.	self assert: (Time h: 7 m: 0 s: 0) asSource equals: '(Time h: 7)'.	self assert: (Time h: 7 m: 0) asSource equals: '(Time h: 7)'.	self assert: (Time h: 7) asSource equals: '(Time h: 7)'.	self assert: (Time h: 0) asSource equals: 'Time zero'.	self assert: Time zero asSource equals: 'Time zero'</body><body package="Values Testing">testTimestamp	self		assert: (Timestamp d: 15 m: 7 y: 2007 h: 7 m: 27 s: 13) asSource		equals: '(Timestamp d: 15 m: 7 y: 2007 h: 7 m: 27 s: 13)'.	self		assert: (Timestamp d: 15 m: 7 y: 2007 h: 7 m: 27 s: 0) asSource		equals: '(Timestamp d: 15 m: 7 y: 2007 h: 7 m: 27)'.	self		assert: (Timestamp d: 15 m: 7 y: 2007 h: 7 m: 27) asSource		equals: '(Timestamp d: 15 m: 7 y: 2007 h: 7 m: 27)'.	self		assert: (Timestamp d: 15 m: 7 y: 2007 h: 7 m: 0 s: 0) asSource		equals: '(Timestamp d: 15 m: 7 y: 2007 h: 7)'.	self		assert: (Timestamp d: 15 m: 7 y: 2007 h: 7 m: 0) asSource		equals: '(Timestamp d: 15 m: 7 y: 2007 h: 7)'.	self		assert: (Timestamp d: 15 m: 7 y: 2007 h: 7) asSource		equals: '(Timestamp d: 15 m: 7 y: 2007 h: 7)'.	self		assert: (Timestamp d: 15 m: 7 y: 2007 h: 0) asSource		equals: '(Timestamp d: 15 m: 7 y: 2007)'.	self		assert: (Timestamp d: 15 m: 7 y: 2007) asSource		equals: '(Timestamp d: 15 m: 7 y: 2007)'</body><body package="Values Tools Testing">testValuespecificationExample	self		assert: ValueSpecification example asSource		equals: '(ValueSpecification	constants: (Array		with: (ConstantSpecification selector: #name comment: ''first there were names'' type: #{String})		with: (OptionalConstantSpecification selector: #default comment: ''if nothing is said'' type: #{String} default: ''String new'')		with: (ArraySpecification selector: #list comment: ''a list of things'')		with: (DictionarySpecification selector: #properties comment: ''The Properties'')))'</body></methods><methods><class-id>ValuemapTest</class-id> <category>Testing</category><body package="Values Testing">testAdding	| od od1 |	od := Valuemap new.	self assert: od isEmpty.	od add: #foo -&gt; 'bar'.	self assert: od size = 1.	self assert: (od atIndex: 1) = (#foo -&gt; 'bar').	self assert: (od at: #foo) = 'bar'.	od at: #baz put: 'xxx'.	self assert: od size = 2.	self assert: (od atIndex: 2) = (#baz -&gt; 'xxx').	self assert: (od at: #baz) = 'xxx'.	od1 := Valuemap new.	od1 add: #foo -&gt; 'baz'.	od1 at: #baz put: 'yyy'.	od addAll: od1.	self assert: od size = 2.	self assert: (od at: #foo) = 'baz'.	self assert: (od at: #baz) = 'yyy'.</body><body package="Values Testing">testAddingWithGrowth	"add iteratively elements, so that the dictionary must grow"	| letters od od1 |	letters := #(#a #b #c #d #e #f #g #h #i #j #k #l #m #n #o #p #q #r #s #t #u #v #w #x #y #z).	od := Valuemap new.	self shouldnt: [letters do: [:symbol | od add: symbol -&gt; symbol asString]] raise: Error.	self assert: od keys asArray = #(#a #b #c #d #e #f #g #h #i #j #k #l #m #n #o #p #q #r #s #t #u #v #w #x #y #z).	od1 := Valuemap new.	self shouldnt: [letters do: [:symbol | od1 at: symbol put: symbol asString]] raise: Error.	self assert: od1 keys asArray = #(#a #b #c #d #e #f #g #h #i #j #k #l #m #n #o #p #q #r #s #t #u #v #w #x #y #z).</body><body package="Values Testing">testComparing	self assert: (Valuemap with: #foo -&gt; 'bar') = (Valuemap with: #foo -&gt; 'bar').	self deny: (Valuemap with: #foo -&gt; 'bar') == (Valuemap with: #foo -&gt; 'bar').	self deny: (Valuemap with: #foo -&gt; 'bar') = (Dictionary with: #foo -&gt; 'bar').	self deny: (Dictionary with: #foo -&gt; 'bar') = (Valuemap with: #foo -&gt; 'bar').	self assert: (Valuemap with: #foo -&gt; 'bar' with: $a -&gt; 123) = (Valuemap with: #foo -&gt; 'bar' with: $a -&gt; 123).	self deny: (Valuemap with: #foo -&gt; 'bar' with: $a -&gt; 123) = (Valuemap with: $a -&gt; 123 with: #foo -&gt; 'bar' ).	self deny: (Valuemap with: #foo -&gt; 'bar' with: $a -&gt; 123) = (Valuemap with: #foo -&gt; 123 with: $a -&gt; 'bar' ).	self deny: (Valuemap with: #foo -&gt; 'bar' with: $a -&gt; 123) = (Valuemap with: #foo -&gt; 'bar' with: $a -&gt; 1234).	self deny: (Valuemap with: #foo -&gt; 'bar' with: $a -&gt; 123) = (Valuemap with: #foo -&gt; 'bars' with: $a -&gt; 123).	self deny: (Valuemap with: #foo -&gt; 'bar' with: $a -&gt; 123) = (Valuemap with: #foo -&gt; 'bar' with: $a -&gt; 123 with: '' -&gt; 0).</body><body package="Values Testing">testDescribeAndReadBackNew	| inst |	inst := Valuemap new.	self assert: inst asDescription = (Compiler evaluate: inst asSource) asDescription</body><body package="Values Testing">testEnumeration	| od keys |	od := Valuemap new.	od add: #foo -&gt; 'bar'.	od at: #baz put: 'xxx'.	od associationsDo: [:assoc |		self assert: (assoc isKindOf: Association).		self assert: assoc key isSymbol.		self assert: assoc value isString].	self assert: od keys asArray = #(#foo #baz).	self assert: od values asArray = #('bar' 'xxx').	keys := OrderedCollection new.	od keysDo: [:k | keys add: k].	self assert: keys asArray = #(#foo #baz).</body><body package="Values Testing">testExampleSource	self assert: Valuemap example asSource = '((Valuemap new: 17)	add: #title -&gt; ''Valuemap class example with examples of all basic values'';	add: #boolean -&gt; true;	add: #character -&gt; $A;	add: #symbol -&gt; #mySymbol;	add: #string -&gt; ''with umlauts and euro: äöüß€'';	add: #schlüssel -&gt; nil;	add: #integer -&gt; 42;	add: #number -&gt; 3.14;	add: #date -&gt; (Date d: 27 m: 3 y: 2022);	add: #time -&gt; (Time h: 12 m: 18);	add: #timestamp -&gt; (Timestamp d: 27 m: 3 y: 2022 h: 12 m: 18);	add: #duration -&gt; (Duration nanoseconds: 300000000000);	add: #color -&gt; (ColorValue fromBytesRed: 127 green: 0 blue: 0);	add: #knownColor -&gt; ColorValue red;	add: #array -&gt; #(#one ''two'' 3);	add: #bytearray -&gt; #[1 2 3];	add: #valuemap -&gt; (Valuemap		with: #test -&gt; true		with: #two -&gt; 2		with: #none -&gt; nil);	yourself)'</body><body package="Values Testing">testIndexOf	| od |	od := Valuemap new.	self assert: od isEmpty.	self assert: (od indexOf: #foo) isZero.	od add: #foo -&gt; 'bar'.	self assert: od size = 1.	self assert: (od indexOf: #foo) = 1.	self assert: (od indexOf: #baz) isZero.	od at: #baz put: 'xxx'.	self assert: od size = 2.	self assert: (od indexOf: #baz) = 2.</body><body package="Values Testing">testIndexedAccess	| od |	od := Valuemap new.	od add: #foo -&gt; 'bar'.	self assert: od size = 1.	self assert: (od atIndex: 1) = (#foo -&gt; 'bar').	self should: [od atIndex: 0] raise: SubscriptOutOfBoundsError.	self should: [od atIndex: 2] raise: SubscriptOutOfBoundsError.	self should: [od atIndex: #key] raise: NonIntegerIndexError.	self should: [od atIndex: '1'] raise: NonIntegerIndexError.</body><body package="Values Testing">testKeyedAccess	| od |	od := Valuemap new.	od add: #foo -&gt; 'bar'.	od at: #baz put: 'xxx'.	self assert: od size = 2.	self assert: (od at: #foo) = 'bar'.	self assert: (od at: #baz) = 'xxx'.	self should: [od at: #bar] raise: NotFoundError.	self assert: (od at: #bar ifAbsent: [nil]) isNil.</body><body package="Values Testing">testReadBackAllTestInstances	(Valuemap class organization listAtCategoryNamed: (Valuemap class whichCategoryIncludesSelector: #example)) do: [:sel |		| inst readInst |		inst := Valuemap perform: sel.		self shouldnt: [readInst := Compiler evaluate: inst asSource] raise: Error.		self assert: inst asSource = readInst asSource]</body><body package="Values Testing">testRemoving	| od |	od := Valuemap new.	self assert: od isEmpty.	self should: [od removeKey: #foo] raise: NotFoundError.	self shouldnt: [od removeKey: #foo ifAbsent: nil] raise: NotFoundError.	self assert: (od removeKey: #foo ifAbsent: nil) isNil.	od add: #foo -&gt; 'bar'.	self assert: od size = 1.	self assert: od keys asArray = #(#foo).	self assert: (od removeKey: #foo) = 'bar'.	self assert: od size = 0.	self assert: od keys asArray = #().	od add: #foo -&gt; 'bar'.	od at: #baz put: 'xxx'.	self assert: od size = 2.	self assert: od keys asArray = #(#foo #baz).	self should: [od removeKey: #zzz] raise: NotFoundError.	self shouldnt: [od removeKey: #zzz ifAbsent: nil] raise: NotFoundError.	self assert: od size = 2.	self assert: od keys asArray = #(#foo #baz).	self assert: (od removeKey: #foo) = 'bar'.	self assert: od size = 1.	self assert: od keys asArray = #(#baz)</body></methods><methods><class-id>ValueSpecification</class-id> <category>source generation private</category><body package="Values Tools">addChange: aRefactoryChangeOrNil to: compositeChange	aRefactoryChangeOrNil ifNotNil: [compositeChange addChange: aRefactoryChangeOrNil]</body><body package="Values Tools">combinationsOf: elements	"&lt;SequenceableCollection of: (SequenceableCollection of: BindingSpecification)&gt;"	"sorted, so that all parameters are first and no optional parameters are last"	| head tail tailcombinations withHead |	elements isEmpty ifTrue: [		^#(#())].	head := elements first.	tail := elements copyFrom: 2 to: elements size.	tailcombinations := self combinationsOf: tail.	withHead := tailcombinations collect: [:combo | (Array with: head) , combo].	^withHead , tailcombinations</body><body package="Values Tools">exampleFor: aTargetClass	"&lt;AddMethodChange | nil&gt;"	| source |	aTargetClass isLeafClass ifFalse: [		^nil].	source := (aTargetClass class includesSelector: #example)		ifTrue: [			[	| example |				example := aTargetClass perform: #example.				example asMethodSourceNamed: 'example'			] on: Error do: [:ex |				self sourceExampleFor: aTargetClass]]		ifFalse: [self sourceExampleFor: aTargetClass].	^self addMethod: source for: aTargetClass class in: #'test instances'</body><body package="Values Tools">initializerFor: aTargetClass	"&lt;AddMethodChange | nil&gt;"	self constants isEmpty ifTrue: [		^nil].	^self		addMethod: (self sourceInitializerFor: aTargetClass)		for: aTargetClass		in: #'initialize-release'</body><body package="Values Tools">needsPassInstVars	"&lt;Boolean&gt;"	^self constants anySatisfy: [:constant | constant passModeString = #value asString]</body><body package="Values Tools">parameterCombinations	"&lt;SequenceableCollection of: (SequenceableCollection of: BindingSpecification)&gt;"	"sorted, so that all parameters are first and no optional parameters are last"	"each combinations contains the right constants in the original order"	| grouped required optional |	grouped := self constants groupedBy: [:c | c isOptional].	required := grouped at: false ifAbsent: [#()].	optional := grouped at: true ifAbsent: [#()].	^((self combinationsOf: optional) collect: [:optionals |		| selection |		selection := (required , optionals) asSet.		self constants select: [:c | selection includes: c]	]) reject: [:p |		p isEmpty]</body><body package="Values Tools">passInstVarsFor: aTargetClass	"&lt;AddMethodChange | nil&gt;"	self needsPassInstVars ifFalse: [		^nil].	[self sourcePassInstVarsOf: aTargetClass] on: NotFoundError do: [:ex |		^nil].	^self addMethod: (self sourcePassInstVarsOf: aTargetClass) for: aTargetClass in: #marshaling</body><body package="Values Tools">printSelector	^self class printSelector</body><body package="Values Tools">sourceConstructorFor: usedConstants	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 60).	usedConstants do: [:constant | wst nextPutAll: constant parameterString] separatedBy: [		wst space].	wst		crtab;		nextPutAll: '| inst |';		crtab;		nextPutAll: 'inst := self new.';		crtab;		nextPutAll: 'inst initialize';		nextPutAll: self constants first capitalizedName;		nextPut: $:;		space;		nextPutAll: (self constants first argumentOrNilStringWhen: (usedConstants includes: self constants first)).	(self constants copyFrom: 2 to: self constants size) do: [:constant |		wst			space;			nextPutAll: constant setterName;			space;			nextPutAll: (constant argumentOrNilStringWhen: (usedConstants includes: constant))].	wst		nextPut: $.;		crtab;		nextPutAll: '^inst'.	^wst contents</body><body package="Values Tools">sourceExampleFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 60).	wst		nextPutAll: 'example';		crtab;		nextPut: $^;		nextPutAll: aTargetClass name.	self constants isEmpty		ifTrue: [wst nextPutAll: ' new']		ifFalse: [		self constants do: [:constant |			wst				crtab;				tab;				nextPutAll: (constant exampleParameterStringFor: aTargetClass)]].	^wst contents</body><body package="Values Tools">sourceInitializeCallString	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 60).	wst		nextPutAll: 'initialize';		nextPutAll: self constants first capitalizedName;		nextPut: $:;		space;		nextPutAll: self constants first argumentName.	(self constants copyFrom: 2 to: self constants size) do: [:constant |		wst			space;			nextPutAll: constant parameterString].	^wst contents</body><body package="Values Tools">sourceInitializerFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 60).	wst nextPutAll: self sourceInitializeCallString.	self constants do: [:constant |		wst			crtab;			nextPutAll: (constant initializeExpressionFor: aTargetClass);			nextPut: $.].	wst		crtab;		nextPutAll: 'self beImmutable'.	^wst contents</body><body package="Values Tools">sourceOptionalConstructorFor: usedConstants	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 60).	usedConstants do: [:constant | wst nextPutAll: constant parameterString] separatedBy: [		wst space].	wst		crtab;		nextPutAll: '^self'.	self constants do: [:constant |		wst			space;			nextPutAll: constant setterName;			space;			nextPutAll: (constant argumentOrNilStringWhen: (usedConstants includes: constant))].	^wst contents</body><body package="Values Tools">sourcePassInstVarsOf: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 60).	wst		nextPutAll: #passInstVars asString;		crtab;		nextPut: $";		nextPutAll: 'for OpenTalk StSt';		nextPut: $";		cr;		crtab;		nextPutAll: '^#('.	aTargetClass allInstVarNames do: [:ivar |		| selector constant |		selector := ivar asSymbol.		constant := self constants detect: [:c | c selector = selector].		wst nextPutAll: constant passModeString] separatedBy: [		wst space].	wst nextPut: $).	^wst contents</body><body package="Values Tools">sourcePrintvalueWith	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 100).	wst		nextPutAll: #printvalueWith: asString;		nextPutAll: ' printer';		crtab;		nextPutAll: '| args |';		crtab;		nextPutAll: 'args := OrderedCollection new.'.	self constants do: [:constant |		wst			crtab;			nextPutAll: 'args add: (printer ';			nextPutAll: constant printExpression;			nextPutAll: ').'].	wst		crtab;		nextPutAll: '^printer printvalue: self arguments: args'.	^wst contents</body><body package="Values Tools">sourcePrintvalueWithFor: aTargetClass	"&lt;AddMethodChange | nil&gt;"	^self addMethod: self sourcePrintvalueWith for: aTargetClass in: #printing</body></methods><methods><class-id>ValueSpecification</class-id> <category>source generation</category><body package="Values Tools">addMethodsFor: aTargetClass to: compositeChange	aTargetClass hasSpecification ifTrue: [		| parameterCombinations |		(self changesForInstvarsOf: aTargetClass) do: [:change |			self addChange: change to: compositeChange].		parameterCombinations := self parameterCombinations.		self			addChange: (self				addMethod: (self sourceConstructorFor: parameterCombinations first)				for: aTargetClass class				in: #'instance creation')			to: compositeChange.		(parameterCombinations copyFrom: 2 to: parameterCombinations size) do: [:parameters |			self				addChange: (self					addMethod: (self sourceOptionalConstructorFor: parameters)					for: aTargetClass class					in: #'instance creation optional')				to: compositeChange].		self addChange: (self initializerFor: aTargetClass) to: compositeChange.		self constants do: [:constantSpec |			self addChange: (constantSpec accessorFor: aTargetClass) to: compositeChange]].	aTargetClass == Value ifTrue: [		^self].	aTargetClass hasSpecification ifTrue: [		self addChange: (self passInstVarsFor: aTargetClass) to: compositeChange.		self addChange: (self sourcePrintvalueWithFor: aTargetClass) to: compositeChange].	aTargetClass isLeafClass ifTrue: [		"should go into the test resources package"		self addChange: (self exampleFor: aTargetClass) to: compositeChange]</body><body package="Values Tools">changesForInstvarsOf: aTargetClass	"&lt;Collection of: Change&gt;"	| changes |	changes := OrderedCollection new.	changes addAll: (self changesForObsoleteInstVarsOf: aTargetClass).	changes addAll: (self classChangeForChangingInstVarsOf: aTargetClass).	^changes</body><body package="Values Tools">changesForObsoleteInstVarsOf: aTargetClass	| changes constantNames obsoleteInstvars methodsReferencingOldInstVars obsoleteConstructors |	changes := OrderedCollection new.	constantNames := self constants collect: [:const | const name].	obsoleteInstvars := aTargetClass instVarNames reject: [:varName |		constantNames includes: varName].	obsoleteInstvars isEmpty ifTrue: [		^changes].	methodsReferencingOldInstVars := obsoleteInstvars inject: Set new into: [:set :varName |		set addAll: (aTargetClass whichSelectorsAccess: varName).		set].	(methodsReferencingOldInstVars detect: [:selector | 'initialize*' match: selector asString] ifNone: [nil]) ifNotNil: [:initializer |		obsoleteConstructors := aTargetClass class whichSelectorsReferTo: initializer.		obsoleteConstructors do: [:constructor |			changes add: (RemoveMethodChange remove: constructor from: aTargetClass class)]].	methodsReferencingOldInstVars do: [:selector |		changes add: (RemoveMethodChange remove: selector from: aTargetClass)].	^changes</body><body package="Values Tools">classChangeForChangingInstVarsOf: aTargetClass	"&lt;SequenceableCollection of: AddClassChange&gt;"	| localConstants newInstvarString oldInstvarString change newDefinition |	localConstants := self constants reject: [:const | aTargetClass superclass allInstVarNames includes: const name].	newInstvarString := localConstants inject: String new into: [:string :const | string , const name , ' '].	oldInstvarString := aTargetClass instanceVariablesString.	newInstvarString = oldInstvarString ifTrue: [		^#()].	newDefinition := aTargetClass definition		copyReplaceAll: 'instanceVariableNames: ' , oldInstvarString printString		with: 'instanceVariableNames: ' , newInstvarString printString.	change := AddClassChange definition: newDefinition.	^Array with: change</body></methods><methods><class-id>ValueSpecification</class-id> <category>printing</category><body package="Values Tools">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer array: 'constants' value: self constants).	^printer printvalue: self arguments: args</body></methods><methods><class-id>ValueSpecification</class-id> <category>initialize-release</category><body package="Values Tools">initializeConstants: constantsArray	(constantsArray notNil and: [	constantsArray notEmpty]) ifTrue: [		constants := (Array withAll: constantsArray) beImmutable].	self beImmutable</body></methods><methods><class-id>ValueSpecification</class-id> <category>accessing</category><body package="Values Tools">constants	^constants ifNil: [#()]</body></methods><methods><class-id>ValueSpecification class</class-id> <category>accessing</category><body package="Values Tools">printSelector	^#printvalueWith:</body></methods><methods><class-id>ValueSpecification class</class-id> <category>instance creation</category><body package="Values Tools">constants: constantsArray	| inst |	inst := self new.	inst initializeConstants: constantsArray.	^inst</body></methods><methods><class-id>ValueSpecification class</class-id> <category>test instances</category><body package="Values Tools">example	^ValueSpecification constants: (Array		with: (ConstantSpecification			selector: #name			comment: 'first there were names'			type: #{String})		with: (OptionalConstantSpecification			selector: #default			comment: 'if nothing is said'			type: #{String}			default: 'String new')		with: (ArraySpecification selector: #list comment: 'a list of things')		with: (DictionarySpecification selector: #properties comment: 'The Properties'))</body><body package="Values Tools">exampleAllOptional	^ValueSpecification constants: (Array		with: (OptionalConstantSpecification			selector: #name			comment: 'first there were names'			type: #{String}			default: 'String new')		with: (OptionalConstantSpecification			selector: #default			comment: 'if nothing is said'			type: #{String}			default: 'String new')		with: (ArraySpecification selector: #list comment: 'a list of things')		with: (DictionarySpecification selector: #properties comment: 'The Properties'))</body><body package="Values Tools">exampleNoOptional	^ValueSpecification constants: (Array		with: (ConstantSpecification selector: #name type: #{String})		with: (ConstantSpecification selector: #default type: #{String})		with: (ConstantSpecification selector: #list type: #{Array})		with: (ConstantSpecification selector: #properties type: #{Valuemap}))</body></methods><methods><class-id>BindingSpecification</class-id> <category>source generation</category><body package="Values Tools">accessorExpressionFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 30).	wst		nextPutAll: self name;		nextPutAll: ' ifNil: [';		nextPutAll: (self defaultFor: aTargetClass);		nextPut: $].	^wst contents</body><body package="Values Tools">accessorFor: aTargetClass	| sourceAccessor |	sourceAccessor := self sourceAccessorFor: aTargetClass.	(aTargetClass needs: sourceAccessor) ifFalse: [		^nil].	^AddMethodChange compile: sourceAccessor in: aTargetClass classified: #accessing</body><body package="Values Tools">argumentName	"&lt;String&gt;"	^self name , self typeName</body><body package="Values Tools">argumentOrNilStringWhen: useArgument	"&lt;String&gt;"	useArgument ifFalse: [^nil printString].	^self argumentName</body><body package="Values Tools">capitalizedName	"&lt;String&gt;"	^self name copyReplaceFrom: 1 to: 1 with: (String with: self name first asUppercase)</body><body package="Values Tools">exampleParameterStringFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 30).	wst		nextPutAll: self setterName;		space;		nextPutAll: (self exampleStringFor: aTargetClass).	^wst contents</body><body package="Values Tools">exampleStringFor: aTargetClass	"&lt;String&gt;"	^self type value literalExample asSourceFor: aTargetClass</body><body package="Values Tools">initializeExpressionFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPutAll: self name;		nextPutAll: ' := ';		nextPutAll: self argumentName.	^wst contents</body><body package="Values Tools">parameterString	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 30).	wst		nextPutAll: self setterName;		space;		nextPutAll: self argumentName.	^wst contents</body><body package="Values Tools">pragmaMessageString	"&lt;String&gt;"	self subclassResponsibility</body><body package="Values Tools">pragmaString	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 30).	wst		nextPut: $&lt;;		nextPutAll: self pragmaMessageString;		nextPut: $&gt;.	^wst contents</body><body package="Values Tools">printExpression	"&lt;String&gt;"	self subclassResponsibility</body><body package="Values Tools">printSelector	"&lt;Symbol&gt;"	"the first part of the selector used by the print method to print its contents"	self subclassResponsibility</body><body package="Values Tools">setterName	"&lt;String&gt;"	^self name copyWith: $:</body><body package="Values Tools">sourceAccessorFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPutAll: self name;		crtab;		nextPutAll: '"&lt;';		nextPutAll: self typeName;		nextPut: $&gt;.	self comment notEmpty ifTrue: [		wst			crtab;			nextPutAll: self comment].	wst		nextPut: $";		cr;		crtab;		nextPut: $^;		nextPutAll: (self accessorExpressionFor: aTargetClass).	^wst contents</body><body package="Values Tools">typeName	"&lt;String&gt;"	^self type name asString</body></methods><methods><class-id>BindingSpecification</class-id> <category>accessing</category><body package="Values Tools">comment	"&lt;String&gt;"	^comment ifNil: [String new]</body><body package="Values Tools">default	^self typeName, ' new beImmutable'</body><body package="Values Tools">defaultFor: aTargetClass	^self default</body><body package="Values Tools">name	"&lt;String&gt;"	^selector asString</body><body package="Values Tools">passModeString	"for OpenTalk StSt #passInstVars"	^#default asString</body><body package="Values Tools">selector	"&lt;Symbol&gt;	required"	^selector</body><body package="Values Tools">type	"&lt;LiteralBindingReference&gt;	required"	"the class of the constant values"	^self subclassResponsibility</body><body package="Values Tools">valueIn: aValue	"&lt;Value | nil&gt;	the value of the receiver attribute in aValue"	^self subclassResponsibility</body></methods><methods><class-id>BindingSpecification</class-id> <category>testing</category><body package="Values Tools">isOptional	"&lt;Boolean&gt;"	^false</body></methods><methods><class-id>BindingSpecification</class-id> <category>initialize-release</category><body package="Values Tools">initializeSelector: selectorSymbol comment: commentString	selector := selectorSymbol.	(commentString notNil and: [	self comment ~= commentString]) ifTrue: [			comment := commentString].	self beImmutable</body></methods><methods><class-id>BindingSpecification</class-id> <category>printing</category><body package="Values Tools">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'selector' value: self selector).	args add: (printer optional: 'comment' value: comment).	^printer printvalue: self arguments: args</body></methods><methods><class-id>BindingSpecification class</class-id> <category>instance creation</category><body package="Values Tools">selector: selectorSymbol comment: commentString	| inst |	inst := self new.	inst initializeSelector: selectorSymbol comment: commentString.	^inst</body></methods><methods><class-id>BindingSpecification class</class-id> <category>instance creation optional</category><body package="Values Tools">selector: selectorSymbol	^self selector: selectorSymbol comment: nil</body></methods><methods><class-id>Tools.Trippy.ValuemapInspector</class-id> <category>private</category><body package="Values Tools">createInsertionUndo: partCollection before: anIndex	self shouldNotImplement</body><body package="Values Tools">refresh	"Keys in a dictionary are unordered, but for presentation arrange them	in the increasing order of their displayStrings. Do not use #collect: to collect	pairs, because #collect: coalesces equal elements, which we need to avoid."	| pairs originalSelections |	pairs := OrderedCollection new: object size.	object keys do: 		[:each | pairs add: (Inspector safeDisplayStringOf: each) -&gt; each].	linearizedParts := pairs collect: [:each | KeyedElement of: object at: each value].	originalSelections := self selections.	driver := self driverClass for: self.	driver refresh.	self selectAll: originalSelections</body></methods><methods><class-id>ScopeTest</class-id> <category>Testing</category><body package="Values Tools Testing">testScope	self assert: (DictionarySpecification isInScope: UI.Dialog).	self assert: (UI.Dialog nameRelativeTo: DictionarySpecification) equals: 'Dialog'.	self assert: (DictionarySpecification isInScope: Store.Access) not.	self assert: (Store.Access nameRelativeTo: DictionarySpecification) equals: 'Store.Access'</body></methods><methods><class-id>ValueGenerationTest</class-id> <category>Testing</category><body package="Values Tools Testing">testAllOptionalParameterCombinations	| parameterCollections |	parameterCollections := ValueSpecification exampleAllOptional parameterCombinations.	self		assert: (parameterCollections collect: [:parameters |			(parameters collect: [:p | p selector]) asArray]) asArray		equals: #(#(#name #default #list #properties) #(#name #default #list) #(#name #default #properties) #(#name #default) #(#name #list #properties) #(#name #list) #(#name #properties) #(#name) #(#default #list #properties) #(#default #list) #(#default #properties) #(#default) #(#list #properties) #(#list) #(#properties))</body><body package="Values Tools Testing">testArraySpecification	self assert: ArraySpecification example selector equals: #list.	self assert: ArraySpecification example name equals: 'list'.	self assert: ArraySpecification example comment equals: 'a list of things'.	self assert: ArraySpecification example capitalizedName equals: 'List'.	self assert: ArraySpecification example type printString equals: #{Array} printString.	self assert: ArraySpecification example typeName equals: 'Array'.	self assert: ArraySpecification example argumentName equals: 'listArray'.	self		assert: (ArraySpecification example initializeExpressionFor: Testvalue)		equals: '(listArray notNil and: [	listArray notEmpty]) ifTrue: [		list := (Array withAll: listArray) beImmutable]'.	self		assert: (ArraySpecification example initializeExpressionFor: ValueTestingNamespace.Array)		equals: '(listArray notNil and: [	listArray notEmpty]) ifTrue: [		list := (Core.Array withAll: listArray) beImmutable]'.	self		assert: (ArraySpecification example sourceAccessorFor: Testvalue)		equals: 'list	"&lt;Array&gt;	a list of things"	^list ifNil: [#()]'.	self		assert: (ArraySpecification example sourceAccessorFor: ValueTestingNamespace.Array)		equals: (ArraySpecification example sourceAccessorFor: Testvalue)</body><body package="Values Tools Testing">testConstantSpecification	self assert: ConstantSpecification example name equals: 'name'.	self assert: ConstantSpecification example comment equals: 'first there were names'.	self assert: ConstantSpecification example capitalizedName equals: 'Name'.	self assert: ConstantSpecification example type printString equals: #{String} printString.	self assert: ConstantSpecification example typeName equals: 'String'.	self assert: ConstantSpecification example argumentName equals: 'nameString'.	self		assert: (ConstantSpecification example initializeExpressionFor: Testvalue)		equals: 'name := nameString'</body><body package="Values Tools Testing">testConstantSpecificationArgumentName	self assert: ArraySpecification example argumentName equals: 'listArray'.	self assert: DictionarySpecification example argumentName equals: 'propertiesDictionary'.	self assert: ConstantSpecification example argumentName equals: 'nameString'.	self assert: OptionalConstantSpecification example argumentName equals: 'defaultString'</body><body package="Values Tools Testing">testConstantSpecificationExampleString	self		assert: (ArraySpecification example exampleStringFor: Object)		equals: '#(1 #a $x ''name'')'.	self		assert: (DictionarySpecification example exampleStringFor: Object)		equals: '(Valuemap with: 1 -&gt; #symbol with: #key -&gt; ''string'')'.	self		assert: (ConstantSpecification example exampleStringFor: Object)		equals: '''a string'''.	self		assert: (OptionalConstantSpecification example exampleStringFor: Object)		equals: '''a string'''</body><body package="Values Tools Testing">testConstantSpecificationInitializeExpression	self		assert: (ArraySpecification example initializeExpressionFor: Testvalue)		equals: '(listArray notNil and: [	listArray notEmpty]) ifTrue: [		list := (Array withAll: listArray) beImmutable]'.	self		assert: (DictionarySpecification example initializeExpressionFor: Testvalue)		equals: '(propertiesDictionary notNil and: [	propertiesDictionary notEmpty]) ifTrue: [		properties := (Valuemap withAll: propertiesDictionary) beImmutable]'.	self		assert: (ConstantSpecification example initializeExpressionFor: Testvalue)		equals: 'name := nameString'.	self		assert: (OptionalConstantSpecification example initializeExpressionFor: Testvalue)		equals: '(defaultString notNil and: [	self default ~= defaultString]) ifTrue: [		default := defaultString]'</body><body package="Values Tools Testing">testConstantSpecificationName	self assert: ConstantSpecification example selector equals: #name.	self assert: OptionalConstantSpecification example selector equals: #default.	self assert: ArraySpecification example selector equals: #list.	self assert: DictionarySpecification example selector equals: #properties.	self assert: ConstantSpecification example name equals: 'name'.	self assert: OptionalConstantSpecification example name equals: 'default'.	self assert: ArraySpecification example name equals: 'list'.	self assert: DictionarySpecification example name equals: 'properties'.	self assert: ConstantSpecification example comment equals: 'first there were names'.	self assert: OptionalConstantSpecification example comment equals: 'if nothing is said'.	self assert: ArraySpecification example comment equals: 'a list of things'.	self assert: DictionarySpecification example comment equals: 'The Properties'.	self assert: ConstantSpecification example setterName equals: 'name:'.	self assert: OptionalConstantSpecification example setterName equals: 'default:'.	self assert: ArraySpecification example setterName equals: 'list:'.	self assert: DictionarySpecification example setterName equals: 'properties:'.	self assert: ConstantSpecification example capitalizedName equals: 'Name'.	self assert: OptionalConstantSpecification example capitalizedName equals: 'Default'.	self assert: ArraySpecification example capitalizedName equals: 'List'.	self assert: DictionarySpecification example capitalizedName equals: 'Properties'</body><body package="Values Tools Testing">testConstantSpecificationType	self assert: ArraySpecification example type printString equals: #{Array} printString.	self		assert: DictionarySpecification example type printString		equals: #{Dictionary} printString.	self assert: ConstantSpecification example type printString equals: #{String} printString.	self		assert: OptionalConstantSpecification example type printString		equals: #{String} printString.	self assert: ArraySpecification example typeName equals: 'Array'.	self assert: DictionarySpecification example typeName equals: 'Dictionary'.	self assert: ConstantSpecification example typeName equals: 'String'.	self assert: OptionalConstantSpecification example typeName equals: 'String'</body><body package="Values Tools Testing">testDictionarySpecification	self assert: DictionarySpecification example selector equals: #properties.	self assert: DictionarySpecification example name equals: 'properties'.	self assert: DictionarySpecification example comment equals: 'The Properties'.	self assert: DictionarySpecification example capitalizedName equals: 'Properties'.	self		assert: DictionarySpecification example type printString		equals: #{Dictionary} printString.	self assert: DictionarySpecification example typeName equals: 'Dictionary'.	self assert: DictionarySpecification example argumentName equals: 'propertiesDictionary'.	self		assert: (DictionarySpecification example initializeExpressionFor: Testvalue)		equals: '(propertiesDictionary notNil and: [	propertiesDictionary notEmpty]) ifTrue: [		properties := (Valuemap withAll: propertiesDictionary) beImmutable]'.	self		assert: (DictionarySpecification example initializeExpressionFor: ValueTestingNamespace.Array)		equals: '(propertiesDictionary notNil and: [	propertiesDictionary notEmpty]) ifTrue: [		properties := (Core.Valuemap withAll: propertiesDictionary) beImmutable]'.	self		assert: (DictionarySpecification example sourceAccessorFor: Testvalue)		equals: 'properties	"&lt;Dictionary&gt;	The Properties"	^properties ifNil: [Dictionary new beImmutable]'.	self		assert: (DictionarySpecification example sourceAccessorFor: ValueTestingNamespace.Array)		equals: 'properties	"&lt;Dictionary&gt;	The Properties"	^properties ifNil: [Core.Dictionary new beImmutable]'</body><body package="Values Tools Testing">testFullSpecification	self assert: Value specification equals: ValueSpecification new.	self		assert: (OptionalConstantSpecification specification constants collect: [:c |			c selector])		equals: #(#selector #comment #type #default)</body><body package="Values Tools Testing">testNoOptionalParameterCombinations	| parameterCollections |	parameterCollections := ValueSpecification exampleNoOptional parameterCombinations.	self		assert: (parameterCollections collect: [:parameters |			(parameters collect: [:p | p selector]) asArray]) asArray		equals: #(#(#name #default #list #properties))</body><body package="Values Tools Testing">testOptionalConstantSpecification	self assert: OptionalConstantSpecification example name equals: 'default'.	self assert: OptionalConstantSpecification example comment equals: 'if nothing is said'.	self assert: OptionalConstantSpecification example capitalizedName equals: 'Default'.	self		assert: OptionalConstantSpecification example type printString		equals: #{String} printString.	self assert: OptionalConstantSpecification example typeName equals: 'String'.	self assert: OptionalConstantSpecification example argumentName equals: 'defaultString'.	self		assert: (OptionalConstantSpecification example initializeExpressionFor: Testvalue)		equals: '(defaultString notNil and: [	self default ~= defaultString]) ifTrue: [		default := defaultString]'</body><body package="Values Tools Testing">testOptionalParameterCombinations	| parameterCollections |	parameterCollections := ValueSpecification example parameterCombinations.	self		assert: (parameterCollections collect: [:parameters |			(parameters collect: [:p | p selector]) asArray]) asArray		equals: #(#(#name #default #list #properties) #(#name #default #list) #(#name #default #properties) #(#name #default) #(#name #list #properties) #(#name #list) #(#name #properties) #(#name))</body><body package="Values Tools Testing">testOptionalParameters	| parameters |	parameters := ValueSpecification example constants asSet select: [:constant |		constant isOptional not].	self		assert: parameters asArray		equals: (Array with: (ConstantSpecification			selector: #name			comment: 'first there were names'			type: #{String}))</body><body package="Values Tools Testing">testPrintExpression	self		assert: ConstantSpecification example printExpression		equals: 'constant: ''name'' value: self name'.	self		assert: OptionalConstantSpecification example printExpression		equals: 'optional: ''default'' value: default'.	self		assert: ArraySpecification example printExpression		equals: 'array: ''list'' value: self list'.	self		assert: DictionarySpecification example printExpression		equals: 'dictionary: ''properties'' value: self properties'</body><body package="Values Tools Testing">testSource	self		assert: OptionalConstantSpecification specification sourcePrintvalueWith		equals: 'printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: ''selector'' value: self selector).	args add: (printer optional: ''comment'' value: comment).	args add: (printer constant: ''type'' value: self type).	args add: (printer optional: ''default'' value: default).	^printer printvalue: self arguments: args'</body><body package="Values Tools Testing">testSource2	self		assert: ValueSpecification specification sourcePrintvalueWith		equals: 'printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer array: ''constants'' value: self constants).	^printer printvalue: self arguments: args'</body><body package="Values Tools Testing">testSourceConstructorWithoutOptionals	| parameters |	parameters := ValueSpecification example constants select: [:constant | constant isOptional not].	self		assert: (ValueSpecification example sourceConstructorFor: parameters)		equals: 'name: nameString	| inst |	inst := self new.	inst initializeName: nameString default: nil list: nil properties: nil.	^inst'</body><body package="Values Tools Testing">testSourceExample	self		assert: (ValueSpecification example sourceExampleFor: Object)		equals: 'example	^Object		name: ''a string''		default: ''a string''		list: #(1 #a $x ''name'')		properties: (Valuemap with: 1 -&gt; #symbol with: #key -&gt; ''string'')'</body><body package="Values Tools Testing">testSourceInitialize	self		assert: (ValueSpecification example sourceInitializerFor: Testvalue)		equals: 'initializeName: nameString default: defaultString list: listArray properties: propertiesDictionary	name := nameString.	(defaultString notNil and: [	self default ~= defaultString]) ifTrue: [		default := defaultString].	(listArray notNil and: [	listArray notEmpty]) ifTrue: [		list := (Array withAll: listArray) beImmutable].	(propertiesDictionary notNil and: [	propertiesDictionary notEmpty]) ifTrue: [		properties := (Valuemap withAll: propertiesDictionary) beImmutable].	self beImmutable'</body></methods><methods><class-id>ValueTestingNamespace.Valuemap</class-id> <category>printing</category><body package="Values Tools Testing">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer dictionary: 'value' value: self value).	^printer printvalue: self arguments: args</body></methods><methods><class-id>ValueTestingNamespace.Valuemap</class-id> <category>accessing</category><body package="Values Tools Testing">value	"&lt;Dictionary&gt;"	^value ifNil: [Core.Dictionary new beImmutable]</body></methods><methods><class-id>ValueTestingNamespace.Valuemap</class-id> <category>initialize-release</category><body package="Values Tools Testing">initializeValue: valueDictionary	(valueDictionary notNil and: [	valueDictionary notEmpty]) ifTrue: [			value := (Core.Valuemap withAll: valueDictionary) beImmutable].	self beImmutable</body></methods><methods><class-id>ValueTestingNamespace.Valuemap</class-id> <category>marshaling</category><body package="Values Tools Testing">passInstVars	"for OpenTalk StSt"	^#(#value)</body></methods><methods><class-id>ValueTestingNamespace.Valuemap class</class-id> <category>instance creation</category><body package="Values Tools Testing">value: valueDictionary	| inst |	inst := self new.	inst initializeValue: valueDictionary.	^inst</body></methods><methods><class-id>ValueTestingNamespace.Valuemap class</class-id> <category>test instances</category><body package="Values Tools Testing">example	^Valuemap value: (Core.Valuemap		with: 1 -&gt; #symbol		with: #key -&gt; 'string')</body></methods><methods><class-id>ValueTestingNamespace.Dictionary</class-id> <category>marshaling</category><body package="Values Tools Testing">passInstVars	"for OpenTalk StSt"	^#(#value)</body></methods><methods><class-id>ValueTestingNamespace.Dictionary</class-id> <category>printing</category><body package="Values Tools Testing">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer dictionary: 'value' value: self value).	^printer printvalue: self arguments: args</body></methods><methods><class-id>ValueTestingNamespace.Dictionary</class-id> <category>accessing</category><body package="Values Tools Testing">value	"&lt;Dictionary&gt;"	^value ifNil: [Core.Dictionary new beImmutable]</body></methods><methods><class-id>ValueTestingNamespace.Dictionary</class-id> <category>initialize-release</category><body package="Values Tools Testing">initializeValue: valueDictionary	(valueDictionary notNil and: [	valueDictionary notEmpty]) ifTrue: [			value := (Core.Valuemap withAll: valueDictionary) beImmutable].	self beImmutable</body></methods><methods><class-id>ValueTestingNamespace.Dictionary class</class-id> <category>instance creation</category><body package="Values Tools Testing">value: valueDictionary	| inst |	inst := self new.	inst initializeValue: valueDictionary.	^inst</body></methods><methods><class-id>ValueTestingNamespace.Dictionary class</class-id> <category>test instances</category><body package="Values Tools Testing">example	^Dictionary value: (Core.Valuemap		with: 1 -&gt; #symbol		with: #key -&gt; 'string')</body></methods><methods><class-id>ValueTestingNamespace.Array</class-id> <category>initialize-release</category><body package="Values Tools Testing">initializeValue: valueArray	(valueArray notNil and: [	valueArray notEmpty]) ifTrue: [			value := (Core.Array withAll: valueArray) beImmutable].	self beImmutable</body></methods><methods><class-id>ValueTestingNamespace.Array</class-id> <category>printing</category><body package="Values Tools Testing">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer array: 'value' value: self value).	^printer printvalue: self arguments: args</body></methods><methods><class-id>ValueTestingNamespace.Array</class-id> <category>accessing</category><body package="Values Tools Testing">value	"&lt;Array&gt;"	^value ifNil: [#()]</body></methods><methods><class-id>ValueTestingNamespace.Array class</class-id> <category>test instances</category><body package="Values Tools Testing">example	^Array value: #(1 #a $x 'name')</body></methods><methods><class-id>ValueTestingNamespace.Array class</class-id> <category>instance creation</category><body package="Values Tools Testing">value: valueArray	| inst |	inst := self new.	inst initializeValue: valueArray.	^inst</body></methods><methods><class-id>TypedConstantSpecification</class-id> <category>initialize-release</category><body package="Values Tools">initializeSelector: selectorSymbol comment: commentString type: typeLiteralBindingReference	selector := selectorSymbol.	(commentString notNil and: [	self comment ~= commentString]) ifTrue: [			comment := commentString].	type := typeLiteralBindingReference.	self beImmutable</body><body package="Values Tools">initializeSelector: selectorSymbol type: typeLiteralBindingReference	selector := selectorSymbol.	type := typeLiteralBindingReference.	self beImmutable</body></methods><methods><class-id>TypedConstantSpecification</class-id> <category>source generation</category><body package="Values Tools">printSelector	^#writeValue:</body></methods><methods><class-id>TypedConstantSpecification</class-id> <category>printing</category><body package="Values Tools">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'selector' value: self selector).	args add: (printer optional: 'comment' value: comment).	args add: (printer constant: 'type' value: self type).	^printer printvalue: self arguments: args</body></methods><methods><class-id>TypedConstantSpecification</class-id> <category>accessing</category><body package="Values Tools">type	"&lt;LiteralBindingReference&gt;	required"	"the class of the constant values"	^type</body></methods><methods><class-id>TypedConstantSpecification class</class-id> <category>instance creation</category><body package="Values Tools">selector: selectorSymbol	"type is required!	#selector:type: must be used to create a non empty instance"	^self shouldNotImplement</body><body package="Values Tools">selector: selectorSymbol comment: commentString type: typeLiteralBindingReference	| inst |	inst := self new.	inst		initializeSelector: selectorSymbol		comment: commentString		type: typeLiteralBindingReference.	^inst</body></methods><methods><class-id>TypedConstantSpecification class</class-id> <category>instance creation optional</category><body package="Values Tools">selector: selectorSymbol type: typeLiteralBindingReference	^self selector: selectorSymbol comment: nil type: typeLiteralBindingReference</body></methods><methods><class-id>CollectionSpecification</class-id> <category>testing</category><body package="Values Tools">isOptional	"empty collection is the default"	^true</body></methods><methods><class-id>CollectionSpecification</class-id> <category>accessing</category><body package="Values Tools">valueIn: aValue	^aValue instVarNamed: self selector asString</body></methods><methods><class-id>ConstantSpecification</class-id> <category>source generation</category><body package="Values Tools">accessorExpressionFor: aTargetClass	"&lt;String&gt;"	^self name</body><body package="Values Tools">pragmaMessageString	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPutAll: 'constant: ';		nextPutAll: self selector printString;		nextPutAll: ' type: ';		nextPutAll: self type printString.	^wst contents</body><body package="Values Tools">printExpression	^'constant: ', self name printString, ' value: self ', self name</body></methods><methods><class-id>ConstantSpecification</class-id> <category>accessing</category><body package="Values Tools">valueIn: aValue	^aValue perform: self selector</body></methods><methods><class-id>ConstantSpecification class</class-id> <category>test instances</category><body package="Values Tools">example	^ConstantSpecification selector: #name comment: 'first there were names' type: #{String}</body></methods><methods><class-id>ArraySpecification</class-id> <category>source generation</category><body package="Values Tools">exampleStringFor: aTargetClass	"&lt;String&gt;"	^'#(1 #a $x ''name'')'</body><body package="Values Tools">initializeExpressionFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPut: $(;		nextPutAll: self argumentName;		nextPutAll: ' notNil and: [';		cr;		tab;		nextPutAll: self argumentName;		nextPutAll: ' notEmpty]) ifTrue: [';		cr;		tab;		tab;		nextPutAll: self name;		nextPutAll: ' := (';		nextPutAll: (Array nameRelativeTo: aTargetClass);		nextPutAll: ' withAll: ';		nextPutAll: self argumentName;		nextPutAll: ') beImmutable]'.	^wst contents</body><body package="Values Tools">pragmaMessageString	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPutAll: 'arrayConstant: ';		nextPutAll: self selector printString.	^wst contents</body><body package="Values Tools">printExpression	^'array: ', self name printString, ' value: self ', self name</body><body package="Values Tools">printSelector	^#literalArraySourceFor:</body></methods><methods><class-id>ArraySpecification</class-id> <category>accessing</category><body package="Values Tools">default	^'#()'</body><body package="Values Tools">type	^#{Array}</body></methods><methods><class-id>ArraySpecification class</class-id> <category>test instances</category><body package="Values Tools">example	^ArraySpecification selector: #list comment: 'a list of things'</body></methods><methods><class-id>OptionalConstantSpecification</class-id> <category>accessing</category><body package="Values Tools">default	^default ifNil: [super default]</body><body package="Values Tools">valueIn: aValue	^aValue instVarNamed: self selector asString</body></methods><methods><class-id>OptionalConstantSpecification</class-id> <category>source generation</category><body package="Values Tools">initializeExpressionFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPut: $(;		nextPutAll: self argumentName;		nextPutAll: ' notNil and: [';		cr;		tab;		nextPutAll: 'self ';		nextPutAll: self name;		nextPutAll: ' ~= ';		nextPutAll: self argumentName;		nextPutAll: ']) ifTrue: [';		cr;		tab;		tab;		nextPutAll: self name;		nextPutAll: ' := ';		nextPutAll: self argumentName;		nextPut: $].	^wst contents</body><body package="Values Tools">pragmaMessageString	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPutAll: 'constant: ';		nextPutAll: self selector printString;		nextPutAll: ' type: ';		nextPutAll: self type printString;		nextPutAll: ' default: ';		nextPutAll: (default ifNil: ['nil'] ifNotNil: [self default printString]).	^wst contents</body><body package="Values Tools">printExpression	^'optional: ', self name printString, ' value: ', self name</body></methods><methods><class-id>OptionalConstantSpecification</class-id> <category>printing</category><body package="Values Tools">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'selector' value: self selector).	args add: (printer optional: 'comment' value: comment).	args add: (printer constant: 'type' value: self type).	args add: (printer optional: 'default' value: default).	^printer printvalue: self arguments: args</body></methods><methods><class-id>OptionalConstantSpecification</class-id> <category>initialize-release</category><body package="Values Tools">initializeSelector: selectorSymbol comment: commentString type: typeLiteralBindingReference default: defaultString	selector := selectorSymbol.	(commentString notNil and: [	self comment ~= commentString]) ifTrue: [			comment := commentString].	type := typeLiteralBindingReference.	(defaultString notNil and: [	self default ~= defaultString]) ifTrue: [			default := defaultString].	self beImmutable</body></methods><methods><class-id>OptionalConstantSpecification</class-id> <category>testing</category><body package="Values Tools">isOptional	^true</body></methods><methods><class-id>OptionalConstantSpecification class</class-id> <category>test instances</category><body package="Values Tools">example	^OptionalConstantSpecification		selector: #default		comment: 'if nothing is said'		type: #{String}		default: 'String new'</body></methods><methods><class-id>OptionalConstantSpecification class</class-id> <category>instance creation</category><body package="Values Tools">selector: selectorSymbol comment: commentString type: typeLiteralBindingReference default: defaultString	| inst |	inst := self new.	inst		initializeSelector: selectorSymbol		comment: commentString		type: typeLiteralBindingReference		default: defaultString.	^inst</body></methods><methods><class-id>OptionalConstantSpecification class</class-id> <category>instance creation optional</category><body package="Values Tools">selector: selectorSymbol comment: commentString type: typeLiteralBindingReference	^self		selector: selectorSymbol		comment: commentString		type: typeLiteralBindingReference		default: nil</body><body package="Values Tools">selector: selectorSymbol type: typeLiteralBindingReference	^self selector: selectorSymbol comment: nil type: typeLiteralBindingReference default: nil</body><body package="Values Tools">selector: selectorSymbol type: typeLiteralBindingReference default: defaultString	^self		selector: selectorSymbol		comment: nil		type: typeLiteralBindingReference		default: defaultString</body></methods><methods><class-id>DictionarySpecification</class-id> <category>accessing</category><body package="Values Tools">default	^self defaultFor: Object</body><body package="Values Tools">defaultFor: aTargetClass	^(Dictionary nameRelativeTo: aTargetClass) , ' new beImmutable'</body><body package="Values Tools">passModeString	^#value asString</body><body package="Values Tools">type	^#{Dictionary}</body></methods><methods><class-id>DictionarySpecification</class-id> <category>source generation</category><body package="Values Tools">exampleStringFor: aTargetClass	"&lt;String&gt;"	^'(' , (Valuemap nameRelativeTo: aTargetClass) , ' with: 1 -&gt; #symbol with: #key -&gt; ''string'')'</body><body package="Values Tools">initializeExpressionFor: aTargetClass	"&lt;String&gt;"	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPut: $(;		nextPutAll: self argumentName;		nextPutAll: ' notNil and: [';		cr;		tab;		nextPutAll: self argumentName;		nextPutAll: ' notEmpty]) ifTrue: [';		cr;		tab;		tab;		nextPutAll: self name;		nextPutAll: ' := (';		nextPutAll: (Valuemap nameRelativeTo: aTargetClass);		nextPutAll: ' withAll: ';		nextPutAll: self argumentName;		nextPutAll: ') beImmutable]'.	^wst contents</body><body package="Values Tools">pragmaMessageString	| wst |	wst := WriteStream on: (String new: 40).	wst		nextPutAll: 'dictionaryConstant: ';		nextPutAll: self selector printString.	^wst contents</body><body package="Values Tools">printExpression	^'dictionary: ', self name printString, ' value: self ', self name</body><body package="Values Tools">printSelector	^#literalDictionarySourceFor:</body></methods><methods><class-id>DictionarySpecification class</class-id> <category>test instances</category><body package="Values Tools">example	^DictionarySpecification selector: #properties comment: 'The Properties'</body></methods><methods><class-id>Core.Time class</class-id> <category>instance creation</category><body package="Values">zero	^self h: 0</body></methods><methods><class-id>Core.Dictionary</class-id> <category>printing</category><body package="Values">printvalueWith: printer	^DictionaryPrintvalue arguments: (self printargumentsWith: printer)</body></methods><methods><class-id>Core.Time</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| wst |	wst := WriteStream on: (String new: 25).	(self hours isZero and: [	self minutes isZero and: [	self seconds isZero]]) ifTrue: [			wst				nextPutAll: (printer classnameOf: self);				nextPutAll: ' zero'.			^LiteralPrintvalue string: wst contents].	wst		nextPut: $(;		nextPutAll: (printer classnameOf: self);		nextPutAll: ' h: ';		nextPutAll: self hours printString.	(self minutes isZero and: [	self seconds isZero]) ifTrue: [			wst nextPut: $).			^LiteralPrintvalue string: wst contents].	wst		nextPutAll: ' m: ';		nextPutAll: self minutes printString.	self seconds isZero ifTrue: [		wst nextPut: $).		^LiteralPrintvalue string: wst contents].	wst		nextPutAll: ' s: ';		nextPutAll: self seconds printString;		nextPut: $).	^LiteralPrintvalue string: wst contents</body></methods><methods><class-id>Core.ByteArray class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^#[42]</body></methods><methods><class-id>Kernel.GeneralBindingReference class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^#{Object}</body></methods><methods><class-id>Core.Time class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^Time h: 11 m: 8 s: 28</body></methods><methods><class-id>Core.Object class</class-id> <category>named values</category><body package="Values">newNamesByValues	"&lt;Dictionary key: Value value: Symbol&gt;"	| dict |	dict := Valuemap new: self namedValueNames size.	self namedValueNames do: [:symbol | dict at: (self perform: symbol) put: symbol].	^dict</body></methods><methods><class-id>Core.Date class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^Date d: 19 m: 5 y: 2006</body></methods><methods><class-id>Core.Date</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| wst |	wst := WriteStream on: (String new: 25).	wst		nextPut: $(;		nextPutAll: (printer classnameOf: self);		nextPutAll: ' d: ';		nextPutAll: self dayOfMonth printString;		nextPutAll: ' m: ';		nextPutAll: self monthIndex printString;		nextPutAll: ' y: ';		nextPutAll: self year printString;		nextPut: $).	^LiteralPrintvalue string: wst contents</body></methods><methods><class-id>Graphics.ColorValue class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^ColorValue red</body></methods><methods><class-id>Core.Object class</class-id> <category>named values</category><body package="Values">nameOrNilFor: aValue	"&lt;Symbol | nil&gt;"	^self namesByValues at: aValue ifAbsent: [nil]</body></methods><methods><class-id>Core.Time class</class-id> <category>instance creation</category><body package="Values">h: hoursInteger m: minutesInteger s: secondsInteger	| inst |	inst := self new.	inst hours: hoursInteger minutes: minutesInteger seconds: secondsInteger.	^inst</body></methods><methods><class-id>Core.Object class</class-id> <category>named values</category><body package="Values">namedValueNames	"&lt;Array of: Symbol&gt;	names to print for special known values"		^#()</body></methods><methods><class-id>Graphics.ColorValue class</class-id> <category>instance creation</category><body package="Values">fromBytes: threeBytes	^self fromBytesRed: threeBytes first green: (threeBytes at: 2) blue: threeBytes last</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>converting</category><body package="Values">rgbIndex	"&lt;Integer&gt;	Three 8 bit RGB numbers interpreted as number for ordering"	^self asByteArray inject: 0 into: [:num :byte | (num bitShift: 8) + byte]</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>class probes</category><body package="Values Tools">isValueClassSelected	^self isClassSelected and: [	(self selectedClass includesBehavior: Value) or: [	self selectedClass includesBehavior: Value class]]</body></methods><methods><class-id>Core.Behavior</class-id> <category>source generation</category><body package="Values Tools">needs: source	"&lt;Boolean&gt;"	| selector parseTree classAndMethod |	parseTree := Refactory.Browser.RBParser parseMethod: source.	selector := parseTree selector.	(self canUnderstand: selector) ifFalse: [		^true].	classAndMethod := self findSelector: selector.	^(classAndMethod first parseTreeFor: selector) ~= parseTree</body></methods><methods><class-id>Core.Date class</class-id> <category>instance creation</category><body package="Values">d: dayInteger m: monthInteger y: yearInteger	^self newDay: dayInteger monthNumber: monthInteger year: yearInteger</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Values">asDescription	"&lt;Text&gt;	produces a text equivalent to the soure with bold leaf values"	^self asDescriptionFor: self class</body></methods><methods><class-id>Core.Timestamp class</class-id> <category>instance creation</category><body package="Values">d: dayInteger m: monthInteger y: yearInteger h: hoursInteger m: minutesInteger s: secondsInteger	| date time |	date := Date d: dayInteger m: monthInteger y: yearInteger.	time := Time h: hoursInteger m: minutesInteger s: secondsInteger.	^self fromDate: date andTime: time</body></methods><methods><class-id>Core.Collection</class-id> <category>comparing</category><body package="Values Tools">betterTestInstanceThan: aCollection	"&lt;Boolean&gt;	true, iff the receiver is better as a test instance than aValue"	^self size &gt;= aCollection size</body></methods><methods><class-id>Core.Class</class-id> <category>testing</category><body package="Values">isInScope: aClass	"&lt;Boolean&gt;	true if aClass is visible by the receiver - aClass can be used in the source without namespace qualifier.	false when aClass cannot be seen by the receiver - use the fullName"	| variableDefinition |	variableDefinition := (NameScope forClass: self) variableAt: aClass name from: nil.	^variableDefinition notNil and: [	variableDefinition binding value == aClass]</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Values">asSourceFor: targetClass	"&lt;String&gt;	produces a string which can be evaluated in the context of targetClass to an object equivalent to the receiver"	| printer printvalue |	printer := ValuePrinter newFor: targetClass.	printvalue := self printvalueWith: printer.	^printvalue sourceWithPrinter: printer</body></methods><methods><class-id>Core.Character class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^$a</body></methods><methods><class-id>Graphics.ColorValue class</class-id> <category>instance creation</category><body package="Values">fromByte: anInteger	^self fromBytes: (ByteArray new: 3 withAll: anInteger)</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Values">printvalueWith: printer	^LiteralPrintvalue string: self storeString</body></methods><methods><class-id>Graphics.ColorValue class</class-id> <category>instance creation</category><body package="Values">fromBytesRed: redByte green: greenByte blue: blueByte	| scale |	scale := ColorValue scalingValue.	^ColorValue		scaledRed: redByte * scale // 255		scaledGreen: greenByte * scale // 255		scaledBlue: blueByte * scale // 255</body></methods><methods><class-id>Core.Dictionary</class-id> <category>dictionary testing</category><body package="Values">isEqualValue: anObject	^self contentsEquals: anObject</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>printing</category><body package="Values">printvalueWith: printer	self isLiteral ifTrue: [		^LiteralPrintvalue string: self storeString].	^ArrayPrintvalue arguments: (self collect: [:item | item printvalueWith: printer])</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| args |	(self class nameOrNilFor: self) ifNotNil: [:symbol |		^LiteralPrintvalue string: (printer classnameOf: self) , ' ' , symbol asString].	args := OrderedCollection new.	args add: (printer constant: 'fromBytesRed' value: (self red * 255) rounded).	args add: (printer constant: 'green' value: (self green * 255) rounded).	args add: (printer constant: 'blue' value: (self blue * 255) rounded).	^printer printvalue: self arguments: args</body></methods><methods><class-id>Core.Time class</class-id> <category>instance creation</category><body package="Values">h: hoursInteger m: minutesInteger	^self h: hoursInteger m: minutesInteger s: 0</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>converting</category><body package="Values">asGrayValue	"&lt;Number&gt;	between 0.0 (Black) and 1.0 (White) suitable for PDF DeviceGray"	^self brightness</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| wst |	wst := WriteStream on: (String new: 25).	wst		nextPut: $(;		nextPutAll: (self origin asSourceFor: printer target);		nextPutAll: ' corner: ';		nextPutAll: (self corner asSourceFor: printer target);		nextPut: $).	^LiteralPrintvalue string: wst contents</body></methods><methods><class-id>Core.Timestamp class</class-id> <category>instance creation</category><body package="Values">d: dayInteger m: monthInteger y: yearInteger	^self d: dayInteger m: monthInteger y: yearInteger h: 0 m: 0 s: 0</body></methods><methods><class-id>Core.Object</class-id> <category>comparing</category><body package="Values">isEqualValue: anObject	^self = anObject</body></methods><methods><class-id>Core.Timestamp</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| wst |	wst := WriteStream on: (String new: 50).	wst		nextPut: $(;		nextPutAll: (printer classnameOf: self);		nextPutAll: ' d: ';		nextPutAll: self dayOfMonth printString;		nextPutAll: ' m: ';		nextPutAll: self month printString;		nextPutAll: ' y: ';		nextPutAll: self year printString.	(self hour isZero and: [	self minute isZero and: [	self second isZero]]) ifTrue: [			wst nextPut: $).			^LiteralPrintvalue string: wst contents].	wst		nextPutAll: ' h: ';		nextPutAll: self hour printString.	(self minute isZero and: [	self second isZero]) ifTrue: [			wst nextPut: $).			^LiteralPrintvalue string: wst contents].	wst		nextPutAll: ' m: ';		nextPutAll: self minute printString.	self second isZero ifTrue: [		wst nextPut: $).		^LiteralPrintvalue string: wst contents].	wst		nextPutAll: ' s: ';		nextPutAll: self second printString;		nextPut: $).	^LiteralPrintvalue string: wst contents</body></methods><methods><class-id>Core.Symbol class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^#symbol</body></methods><methods><class-id>Graphics.ColorValue class</class-id> <category>named values</category><body package="Values">namedValueNames	"The selection is the common set of color names with identical colors in VW and Squeak/Pharo	The colors are all variations of min and max of the 3 components"	"self namesByValues"		^#(#black #white	#red #green #blue	#cyan #magenta #yellow)</body></methods><methods><class-id>Core.Time class</class-id> <category>instance creation</category><body package="Values">h: hoursInteger	^self h: hoursInteger m: 0 s: 0</body></methods><methods><class-id>Kernel.GeneralBindingReference</class-id> <category>testing</category><body package="Values">isEqualValue: aQualifiedName	^self class == aQualifiedName class and: [	path = aQualifiedName path]</body></methods><methods><class-id>Core.Dictionary</class-id> <category>printing</category><body package="Values">keysForPrinting	^[self keys asSortedCollection] on: Error do: [:ex | ex return: self keys]</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>testing</category><body package="Values">isEmpty	^self scaledRed isNil and: [	self scaledGreen isNil and: [	self scaledBlue isNil]]</body></methods><methods><class-id>Core.Object class</class-id> <category>named values</category><body package="Values">namesByValues	"&lt;Dictionary key: Value value: Symbol&gt;"	^Value namedValuesAt: self ifAbsentPut: [self newNamesByValues]</body></methods><methods><class-id>Core.Timestamp class</class-id> <category>instance creation</category><body package="Values">d: dayInteger m: monthInteger y: yearInteger h: hoursInteger m: minutesInteger	^self d: dayInteger m: monthInteger y: yearInteger h: hoursInteger m: minutesInteger s: 0</body></methods><methods><class-id>Core.String class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^'a string'</body></methods><methods><class-id>Core.Timestamp class</class-id> <category>instance creation</category><body package="Values">d: dayInteger m: monthInteger y: yearInteger h: hoursInteger	^self d: dayInteger m: monthInteger y: yearInteger h: hoursInteger m: 0 s: 0</body></methods><methods><class-id>Core.Object class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^self error: 'this is no literal object'</body></methods><methods><class-id>Core.Dictionary</class-id> <category>printing</category><body package="Values">printargumentsWith: aPrinter	^self keysForPrinting collect: [:key |		DictionaryPrintargument			name: (key printvalueWith: aPrinter)			value: ((self at: key) printvalueWith: aPrinter)]</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>converting</category><body package="Values">asByteArray	^ByteArray		with: (self scaledRed bitShift: -5)		with: (self scaledGreen bitShift: -5)		with: (self scaledBlue bitShift: -5)</body></methods><methods><class-id>Core.Boolean class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^true</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>printing</category><body package="Values Tools">literalExample	^nil</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Values">asSource	"&lt;String&gt;	produces a string which can be evaluated in the context of the receiver class to an object equivalent to the receiver"	^self asSourceFor: self class</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="Values">nameRelativeTo: targetClass	"&lt;String&gt;"	"self nameRelativeTo: Object"	| ref |	(targetClass isInScope: self) ifTrue: [		^self name asString].	ref := self fullyQualifiedReference.	ref environmentName ifNil: [ref := self fullyQualifiedReferenceFrom: Root].	^ref asString</body></methods><methods><class-id>Core.ArithmeticValue class</class-id> <category>constants access</category><body package="Values Tools">literalExample	^self unity toMinimumGenerality</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Values">asDescriptionFor: targetClass	"&lt;Text&gt;	produces a text equivalent to the source"	| printer printvalue |	printer := ValuePrinter newFor: targetClass.	printvalue := self printvalueWith: printer.	^printvalue description</body></methods><methods><class-id>Core.Timestamp class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^Timestamp d: 19 m: 5 y: 2006 h: 11 m: 7 s: 55</body></methods><methods><class-id>Core.Point</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| string |	string := (self x asSourceFor: printer target) , ' @ ' , (self y asSourceFor: printer target).	^LiteralPrintvalue string: string</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>enumerating</category><body package="Values">asArgumentsIn: aBlock	"Evaluate aBlock with the receiver's elements as parameters.	aBlock takes its arguments from the receiver.	'ok'	#(1 2 3) asArgumentsIn: [:a :b :c | a + b + c]	#(1 2 3) asArgumentsIn: [:a :b | a + b]	#(1 2 3) asArgumentsIn: [:a | a]	#(1 2 3) asArgumentsIn: [42]	'not ok'	#(1 2 3) asArgumentsIn: [:a :b :c :d | a + b + c + d]	"	^aBlock cullWithArguments: self asArray</body></methods><methods><class-id>Core.Duration class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^42 nanoseconds</body><body package="Values">nanoseconds: aNumber	^aNumber nanoseconds</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Values Tools">asLiteralSource	"use #asSource"	self halt</body></methods><methods><class-id>Core.Duration</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| wst |	wst := WriteStream on: (String new: 25).	wst		nextPut: $(;		nextPutAll: (printer classnameOf: self);		nextPutAll: ' nanoseconds: ';		nextPutAll: self asNanoseconds printString;		nextPut: $).	^LiteralPrintvalue string: wst contents</body></methods><methods><class-id>Graphics.Rectangle class</class-id> <category>instance creation</category><body package="Values Tools">literalExample	^1@2 extent: 20@10</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>ColorValue</name><environment>Graphics</environment><super>Graphics.SimplePaint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>red green blue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>DictionaryInspector</name><environment>Tools.Trippy</environment><super>Tools.Trippy.PartListAbstractInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>linearizedParts valueOrKeyHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Trippy</category><attributes><package>Tools-Trippy</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Point</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>BrowserNavigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractBrowserNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>history future updateHistoryBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Duration</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>period scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Core</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Rectangle</name><environment>Graphics</environment><super>Graphics.Geometric</super><private>false</private><indexed-type>none</indexed-type><inst-vars>origin corner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>GeneralBindingReference</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class></st-source>