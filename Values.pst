<?xml version="1.0"?><st-source><!-- Name: ValuesNotice: The MIT LicenseCopyright © 2009-2018 Christian HaiderPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Comment: Values are simple immutable literal objects.Runtime support for Values.Defines the root class Value and provides- printing instances- equality- an example.Specifies the responsibilities of subclasses to define the #localSpecificationPackageName: ValuesPadded: trueParcel: #('Values')ParcelName: ValuesVersion: 3.0.4.0Date: 1:58:20 PM October 19, 2024 --><time-stamp>From VisualWorks®, 9.4 of 5. Januar 2024 on 19. Oktober 2024 at 13:58:20</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Emitter</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>printer stream level </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>Emitter</class-id><body>Emitter outputs a Printvalue as formatted source code to a stream.Subclasses write source or text.This implements the second pass of the source generation for Values.Instance Variables	printer	&lt;ValuePrinter&gt;					the printer to resolve namespace names	level	&lt;Integer&gt;						the indention level	stream	&lt;WriteStream | TextStream&gt;		the output stream</body></comment><class><name>TextEmitter</name><environment>Smalltalk</environment><super>Emitter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>TextEmitter</class-id><body>TextEmitter outputs a descriptive text.</body></comment><class><name>TextBlockEmitter</name><environment>Smalltalk</environment><super>TextEmitter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>TextBlockEmitter</class-id><body>TextBlockEmitter emits text as indented block</body></comment><class><name>Value</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>Value</class-id><body>Value is the abstract root object of values (literal objects).All Value classes which have subclasses are considered abstract. Only leaf classes can have instances!Literal objects are created immutable with constructors.The instance variables are object constants.Subclasses must implement the following messages:	class specification		localSpecification</body></comment><class><name>Printvalue</name><environment>Smalltalk</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>Printvalue</class-id><body>A Printvalue holds a representation of a Value to be printed.It consists of	- classname 	&lt;String&gt;										properly resolved against a target class (#name or #fullName)	- arguments 	&lt;SequenceableCollection of: Printargument&gt;		the list of arguments with constructor variable name and a PrintvaluePrintvalues are created when printing the source for a Value in the first pass. The second pass takes the Printvalue and produces a nicely indented soure string for the value.</body></comment><class><name>DictionaryPrintvalue</name><environment>Smalltalk</environment><super>Printvalue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arguments isOrdered </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>DictionaryPrintvalue</class-id><body>DictionaryPrintvalue is used for printing DictionariesInstance Variables:	arguments	&lt;SequenceableCollection of DictionaryPrintargument&gt;	the Printarguments for each entry</body></comment><class><name>TextLineEmitter</name><environment>Smalltalk</environment><super>TextEmitter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>TextLineEmitter</class-id><body>TextLineEmitter emits text as one line</body></comment><class><name>Valuemap</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>order </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>Core.Valuemap</class-id><body>A Valuemap is an ordered dictionary preserving the order in which entries are added.Instances are also used as ordered volatile dictionary, not just as value.In VisualWorks, Valuemap is subclassed from Dictionary to inherit the dictionary API.Instance Variables:	order	&lt;SequenceableCollection of: Object&gt;		the ordered keysThe class used to be named OrderedDictionary, but was renamed for dialect compatibility with Pharo, which has a class named OrderedDictionary with different semantics.</body></comment><class><name>ValuePrinter</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>target </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>ValuePrinter</class-id><body>ValuePrinter creates the source for a Value.For each level, a new ValuePrinter is created.The target class is the compilation target of the created source, as if the source is compiled as method of that class.The scoping from the target defines how class names are printed (with or without namespaces).</body></comment><class><name>Printargument</name><environment>Smalltalk</environment><super>Value</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>Printargument</class-id><body>A Printargument holds the data to print one instance variable (constant) and its value.	- name 	&lt;String&gt; 		the name of the argument	- value 	&lt;Printvalue&gt;	the print value of the valueWith Printvalue it represents the source for a Value</body></comment><class><name>SourceEmitter</name><environment>Smalltalk</environment><super>Emitter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>SourceEmitter</class-id><body>SourceEmitter outputs source code.</body></comment><class><name>DictionaryPrintargument</name><environment>Smalltalk</environment><super>Printargument</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>DictionaryPrintargument</class-id><body>DictionaryPrintargument holds the Printvalues for key and value of an entry in a dictionary.Both key and value can be Values</body></comment><class><name>ValuePrintvalue</name><environment>Smalltalk</environment><super>Printvalue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classname arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>ValuePrintvalue</class-id><body>ValuePrintvalue holds the data to print a Value.Instance Variables:	arguments	&lt;SequenceableCollection of: (Printargument | EmptyArgument)&gt;	the arguments	classname	&lt;String&gt;														the namespace aware name of the class</body></comment><class><name>LineEmitter</name><environment>Smalltalk</environment><super>SourceEmitter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>LineEmitter</class-id><body>Emits source as one line</body></comment><class><name>ArrayPrintvalue</name><environment>Smalltalk</environment><super>Printvalue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>ArrayPrintvalue</class-id><body>ArrayPrintvalue is a special Printvalue for sequentiable collections of Values</body></comment><class><name>BlockEmitter</name><environment>Smalltalk</environment><super>SourceEmitter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>BlockEmitter</class-id><body>Emits source as indented block</body></comment><class><name>LiteralPrintvalue</name><environment>Smalltalk</environment><super>Printvalue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Values</package></attributes></class><comment><class-id>LiteralPrintvalue</class-id><body>LiteralPrintvalue is a Printvalue for literals.Instance Variables:	string	&lt;String&gt;	the representation as a string</body></comment><shared-variable><name>NamedValuesRegistry</name><environment>Value</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Values</package></attributes></shared-variable><methods><class-id>Emitter</class-id> <category>accessing</category><body package="Values">emitterClassFor: printvalue	"&lt;Emitter class&gt;"	^self subclassResponsibility</body><body package="Values">emitterFor: printvalue	"&lt;Emitter&gt;"	^(self emitterClassFor: printvalue) for: self printer on: self stream at: self level</body><body package="Values">level	"&lt;Integer&gt;	the indent level"	^level ifNil: [0]</body><body package="Values">newStream	^self streamClass on: (String new: 100)</body><body package="Values">printer	"&lt;ValuePrinter&gt;"	^printer</body><body package="Values">stream	"&lt;WriteStream | TextStream&gt;	the output stream"	^stream ifNil: [stream := self newStream]</body><body package="Values">streamClass	"&lt;WriteStream class | TextStream class&gt;"	^self subclassResponsibility</body></methods><methods><class-id>Emitter</class-id> <category>writing</category><body package="Values">emit: aString	self stream nextPutAll: aString</body><body package="Values">emitArgument: aPrintargument	self emit: aPrintargument name , ': '.	aPrintargument value sourceFor: self</body><body package="Values">emitArraySourceFor: anArray	self inBracketsDo: [		anArray size &gt; 4			ifTrue: [self emitLongCollection: anArray]			ifFalse: [			self emitSmallCollection: anArray]]</body><body package="Values">emitClass: aString	self emit: aString</body><body package="Values">emitDictionarySourceFor: aDictionaryPrintvalue	self inBracketsDo: [		aDictionaryPrintvalue arguments size &gt; 4			ifTrue: [			self emitLongDictionary: aDictionaryPrintvalue]			ifFalse: [			self emitSmallDictionary: aDictionaryPrintvalue]]</body><body package="Values">emitEmpty: aValuePrintvalue	"write the constructor for an empty instance"	self emitClass: aValuePrintvalue classname.	self emit: ' new'</body><body package="Values">emitLongCollection: aSequenceableCollection	self emit: '(', (OrderedCollection nameRelativeTo: self printer target) , ' new: ' , aSequenceableCollection size printString, ')'.	aSequenceableCollection do: [:value |		self emitSeparator.		self emit: 'add: '.		value sourceFor: self.		self stream nextPut: $;].	self emitSeparator.	self emit: 'yourself'</body><body package="Values">emitLongDictionary: aDictionaryPrintvalue	self emit: '(', (aDictionaryPrintvalue targetClass nameRelativeTo: self printer target), ' new: ' , aDictionaryPrintvalue arguments size printString, ')'.	aDictionaryPrintvalue arguments do: [:argument |		self emitSeparator.		self emit: 'add: '.		argument name sourceFor: self.		self emit: ' -&gt; '.		argument value sourceFor: self.		self stream nextPut: $;].	self emitSeparator.	self emit: 'yourself'</body><body package="Values">emitSeparator	self subclassResponsibility</body><body package="Values">emitSmallCollection: aSequenceableCollection	self emit: (Array nameRelativeTo: self printer target).	aSequenceableCollection do: [:value |		self emitSeparator.		self emit: 'with: '.		value sourceFor: self]</body><body package="Values">emitSmallDictionary: aDictionaryPrintvalue	self emit: (aDictionaryPrintvalue targetClass nameRelativeTo: self printer target).	aDictionaryPrintvalue arguments do: [:argument |		self emitSeparator.		self emit: 'with: '.		argument name sourceFor: self.		self emit: ' -&gt; '.		argument value sourceFor: self]</body><body package="Values">emitValue: aString	self emit: aString</body><body package="Values">inBracketsDo: aZeroArgumentBlock	self stream nextPut: $(.	aZeroArgumentBlock ensure: [self stream nextPut: $)]</body></methods><methods><class-id>Emitter</class-id> <category>initialize-release</category><body package="Values">initializePrinter: aPrinter stream: aWriteStream level: anInteger	printer := aPrinter.	stream := aWriteStream.	level := anInteger</body></methods><methods><class-id>Emitter class</class-id> <category>instance creation</category><body package="Values">for: aPrinter	| inst |	inst := self new.	inst initializePrinter: aPrinter stream: nil level: -1.	^inst</body><body package="Values">for: aPrinter on: aWriteStream at: anInteger	| inst |	inst := self new.	inst initializePrinter: aPrinter stream: aWriteStream level: anInteger.	^inst</body></methods><methods><class-id>TextEmitter</class-id> <category>writing</category><body package="Values">emitArraySourceFor: anArray	self emitSmallCollection: anArray</body><body package="Values">emitBold: aString	self stream nextPutAllText: aString asText allBold</body><body package="Values">emitClass: aString	self emitBold: aString</body><body package="Values">emitDictionarySourceFor: aDictionaryPrintvalue	self emitSmallDictionary: aDictionaryPrintvalue</body><body package="Values">emitSmallCollection: aSequenceableCollection	aSequenceableCollection do: [:value |		self emitSeparator.		value sourceFor: self]</body><body package="Values">emitSmallDictionary: aDictionaryPrintvalue	aDictionaryPrintvalue arguments do: [:argument |		self emitSeparator.		argument name sourceFor: self.		self emit: ': '.		argument value sourceFor: self]</body><body package="Values">emitValue: aString	self emitBold: aString</body></methods><methods><class-id>TextEmitter</class-id> <category>accessing</category><body package="Values">emitterClassFor: printvalue	^printvalue isLine		ifTrue: [TextLineEmitter]		ifFalse: [TextBlockEmitter]</body><body package="Values">streamClass	^TextStream</body></methods><methods><class-id>TextBlockEmitter</class-id> <category>initialize-release</category><body package="Values">initializePrinter: aPrinter stream: aWriteStream level: anInteger	printer := aPrinter.	stream := aWriteStream.	level := anInteger + 1</body></methods><methods><class-id>TextBlockEmitter</class-id> <category>writing</category><body package="Values">emitSeparator	self stream cr.	self level + 1 timesRepeat: [self stream tab]</body><body package="Values">inBracketsDo: aZeroArgumentBlock	aZeroArgumentBlock value</body></methods><methods><class-id>Value</class-id> <category>comparing</category><body package="Values">= anObject	"all instvars must be equal"	^self isEqualValue: anObject</body><body package="Values">hash	^(1 to: self class instSize) inject: 0 into: [:hash :i | hash bitXor: (self instVarAt: i) hash]</body><body package="Values">isEqualValue: anObject	self == anObject ifTrue: [		^true].	self class = anObject class ifFalse: [		^false].	1 to: self class instSize do: [:i |		((self instVarAt: i) isEqualValue: (anObject instVarAt: i)) ifFalse: [			^false]].	^true</body></methods><methods><class-id>Value</class-id> <category>testing</category><body package="Values">isEmpty	^self = self class new</body><body package="Values">notEmpty	^self isEmpty not</body></methods><methods><class-id>Value</class-id> <category>printing</category><body package="Values">printOn: stream	stream nextPutAll: self asSource</body><body package="Values">printvalueWith: printer	^printer printvalue: self arguments: #()</body></methods><methods><class-id>Value</class-id> <category>marshaling</category><body package="Values">passMode	"for OpenTalk StSt (Smalltalk to Smalltalk)"	^#value</body></methods><methods><class-id>Value</class-id> <category>copying</category><body package="Values">postCopy	super postCopy.	self beImmutable</body></methods><methods><class-id>Value class</class-id> <category>class initialization</category><body package="Values">obsolete	self allInstancesDo: #beMutable.	super obsolete</body></methods><methods><class-id>Value class</class-id> <category>named values</category><body package="Values">namedValuesAt: aClass	"&lt;Dictionary key: Value value: Symbol&gt;	the named instances of aClass"	^self namedValuesRegistry at: aClass ifAbsent: [Dictionary new]</body><body package="Values">namedValuesAt: aClass ifAbsentPut: aBlock	"&lt;Dictionary key: Value value: Symbol&gt;	the named instances of aClass"	^self namedValuesRegistry at: aClass ifAbsentPut: aBlock</body><body package="Values">namedValuesRegistry	"&lt;Dictionary key: Class value: (Dictionary key: Value value: Symbol)&gt;	the named instances of classes.	This is a light weight implementation to hold all named instances of all classes, instead of storing them with the class"		^NamedValuesRegistry ifNil: [NamedValuesRegistry := Valuemap new]</body></methods><methods><class-id>Value class</class-id> <category>initialize-release</category><body package="Values">primeRuntime	"reset and load all class variables to fill the caches to avoid lazy initialization at runtime.	This should be executed when deploying after all application fonts and extensions are loaded"	"self primeRuntime"	self resetNamedValuesRegistry.	Object namesByValues</body><body package="Values">resetNamedValuesRegistry	"self resetNamedValuesRegistry"	NamedValuesRegistry := nil</body></methods><methods><class-id>Value class</class-id> <category>specification</category><body package="Values">localSpecification	"specification of the constants with pragmas.	Only for the instvars defined in this class - access the full specification with #specification"	^self subclassResponsibility</body></methods><methods><class-id>Printvalue</class-id> <category>testing</category><body package="Values">isLine	^false</body><body package="Values">isSimple	"does it have to be printed in brackets?	only literals are simple"	^false</body></methods><methods><class-id>Printvalue</class-id> <category>accessing</category><body package="Values">description	"&lt;Text&gt;"	| emitter |	emitter := self textemitterClass new.	self sourceWith: emitter.	^emitter stream contents</body><body package="Values">emitterClass	"&lt;SourceEmitter class&gt;"	^self isLine		ifTrue: [LineEmitter]		ifFalse: [BlockEmitter]</body><body package="Values">sourceFor: outerEmitter	"&lt;String&gt;"	^self sourceWith: (outerEmitter emitterFor: self)</body><body package="Values">sourceWith: emitter	"write yourself with the emitter"	^self subclassResponsibility</body><body package="Values">sourceWithPrinter: aPrinter	"&lt;String&gt;"	| emitter |	emitter := self emitterClass for: aPrinter.	self sourceWith: emitter.	^emitter stream contents</body><body package="Values">textemitterClass	"&lt;SourceEmitter class&gt;"	^self isLine		ifTrue: [TextLineEmitter]		ifFalse: [TextBlockEmitter]</body></methods><methods><class-id>DictionaryPrintvalue</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer array: 'arguments' value: self arguments).	args add: (printer optional: 'isOrdered' value: isOrdered).	^printer printvalue: self arguments: args</body></methods><methods><class-id>DictionaryPrintvalue</class-id> <category>accessing</category><body package="Values">arguments	"&lt;Array&gt;"	^arguments ifNil: [#()]</body><body package="Values">isOrdered	"&lt;Boolean&gt;"	^isOrdered ifNil: [false]</body><body package="Values">sourceWith: emitter	self isEmpty ifTrue: [		^emitter emit: self targetClassname , ' new'].	emitter emitDictionarySourceFor: self</body><body package="Values">targetClass	^self isOrdered		ifTrue: [Valuemap]		ifFalse: [Dictionary]</body><body package="Values">targetClassname	^self targetClass name asString</body></methods><methods><class-id>DictionaryPrintvalue</class-id> <category>testing</category><body package="Values">isEmpty	^self arguments isEmpty</body><body package="Values">isLine	^self isEmpty</body></methods><methods><class-id>DictionaryPrintvalue</class-id> <category>initialize-release</category><body package="Values">initializeArguments: argumentsArray isOrdered: isOrderedBoolean	(argumentsArray notNil and: [	argumentsArray notEmpty]) ifTrue: [			arguments := (Array withAll: argumentsArray) beImmutable].	(isOrderedBoolean notNil and: [	self isOrdered ~= isOrderedBoolean]) ifTrue: [			isOrdered := isOrderedBoolean].	self beImmutable</body></methods><methods><class-id>DictionaryPrintvalue class</class-id> <category>instance creation</category><body package="Values">arguments: argumentsArray isOrdered: isOrderedBoolean	| inst |	inst := self new.	inst initializeArguments: argumentsArray isOrdered: isOrderedBoolean.	^inst</body></methods><methods><class-id>DictionaryPrintvalue class</class-id> <category>instance creation optional</category><body package="Values">arguments: argumentsArray	^self arguments: argumentsArray isOrdered: nil</body><body package="Values">isOrdered: isOrderedBoolean	^self arguments: nil isOrdered: isOrderedBoolean</body></methods><methods><class-id>TextLineEmitter</class-id> <category>writing</category><body package="Values">emitSeparator	self stream space</body></methods><methods><class-id>Core.Valuemap</class-id> <category>private</category><body package="Values">atNewIndex: index put: anAssociation	self basicAt: index put: anAssociation.	tally := tally + 1.	self order addLast: anAssociation key.	self fullCheck</body><body package="Values">noCheckAdd: anAssociation	super noCheckAdd: anAssociation.	self order addLast: anAssociation key</body><body package="Values">setTally	super setTally.	order := nil</body></methods><methods><class-id>Core.Valuemap</class-id> <category>accessing</category><body package="Values">atIndex: index	"&lt;Association&gt;"	^self associationAt: (self order at: index)</body><body package="Values">first	"&lt;Association&gt;"	^self associationAt: self keys first</body><body package="Values">indexOf: aKey	"&lt;Integer&gt;"	^self order indexOf: aKey</body><body package="Values">keys	"&lt;SequenceableCollection of: Object&gt;"	^self order copy</body><body package="Values">last	"&lt;Association&gt;"	^self associationAt: self keys last</body><body package="Values">order	"&lt;SequenceableCollection of: Object&gt;	the order of the keys"	^order ifNil: [order := OrderedCollection new]</body></methods><methods><class-id>Core.Valuemap</class-id> <category>enumerating</category><body package="Values">collect: oneArgumentBlock	| newCollection |	newCollection := self species new: self size.	self keysAndValuesDo: [:eachKey :eachValue | 		newCollection at: eachKey put: (oneArgumentBlock value: eachValue)].	^newCollection</body><body package="Values">do: oneArgumentBlock	self order do: [:key |		oneArgumentBlock value: (self at: key)]</body><body package="Values">keysAndValuesDo: oneArgumentBlock	self order do: [:key |		oneArgumentBlock value: key value: (self at: key)]</body></methods><methods><class-id>Core.Valuemap</class-id> <category>comparing</category><body package="Values">= otherOrderedDictionary	^self class == otherOrderedDictionary class and: [	self size = otherOrderedDictionary size and: [	(1 to: self size) allSatisfy: [:i |		(self atIndex: i) = (otherOrderedDictionary atIndex: i)]]]</body><body package="Values">hash	^(1 to: self size) inject: self class hash into: [:hash :index |		| assoc |		assoc := self atIndex: index.		hash bitXor: (assoc key hash bitXor: assoc value hash)]</body></methods><methods><class-id>Core.Valuemap</class-id> <category>printing</category><body package="Values">keysForPrinting	^self keys</body><body package="Values">printvalueWith: printer	^DictionaryPrintvalue arguments: (self printargumentsWith: printer) isOrdered: true</body></methods><methods><class-id>Core.Valuemap</class-id> <category>copying</category><body package="Values">copyWith: anAssociation 	"Answer a copy of the receiver with anAssociation added"	| copy |	copy := self copy.	copy add: anAssociation.	^copy</body><body package="Values">copyWithAll: aDictionary	"Answer a copy of the receiver with all associations from aDictionary added"	| copy |	copy := self copy.	copy addAll: aDictionary.	^copy</body><body package="Values">postCopy	super postCopy.	order := self order copy</body></methods><methods><class-id>Core.Valuemap</class-id> <category>dictionary enumerating</category><body package="Values">associationsDo: aBlock	"Note: do not use the keys to access anything.	This method is used by #changeCapacityTo: and #rehash where key access is not working"	| assocs |	assocs := Array new: self order size.	super associationsDo: [:assoc | assocs at: (self order indexOf: assoc key) put: assoc].	assocs do: aBlock</body></methods><methods><class-id>Core.Valuemap</class-id> <category>dictionary removing</category><body package="Values">removeKey: key ifAbsent: aBlock	| index element |	index := self findKey: key ifAbsent: nil.	"avoid full block"	index isNil ifTrue: [		^aBlock value].	element := self basicAt: index.	self order remove: element key.	self basicAt: index put: nil.	tally := tally - 1.	self fixCollisionsFrom: index.	^element value</body></methods><methods><class-id>Core.Valuemap</class-id> <category>dictionary testing</category><body package="Values">isEqualValue: anObject	^self = anObject</body></methods><methods><class-id>ValuePrinter</class-id> <category>accessing</category><body package="Values">array: selectorname value: object	"&lt;Printargument | nil&gt;"	object isEmpty ifTrue: [		^nil].	^Printargument name: selectorname value: (object printvalueWith: self)</body><body package="Values">classnameOf: value	^value class nameRelativeTo: self target</body><body package="Values">constant: selectorname value: object	"&lt;Printargument&gt;"	^Printargument name: selectorname value: (object printvalueWith: self)</body><body package="Values">dictionary: selectorname value: object	"&lt;Printargument | nil&gt;"	object isEmpty ifTrue: [		^nil].	^Printargument name: selectorname value: (object printvalueWith: self)</body><body package="Values">optional: selectorname value: object	"&lt;Printargument | nil&gt;"	^object ifNotNil: [		Printargument name: selectorname value: (object printvalueWith: self)]</body><body package="Values">printvalue: aValue arguments: arguments	aValue class new = aValue ifTrue: [		^ValuePrintvalue classname: (self classnameOf: aValue)].	^ValuePrintvalue		classname: (self classnameOf: aValue)		arguments: (arguments select: [:arg |			arg notNil])</body><body package="Values">target	"&lt;Value class&gt;	the class for which the object is printed as if the generated source is included into a method of the class.	Takes the visibility of classes into account for class name generation (with or without namespaces)"	^target</body></methods><methods><class-id>ValuePrinter</class-id> <category>initialize-release</category><body package="Values">initializeTarget: targetClass	target := targetClass</body></methods><methods><class-id>ValuePrinter class</class-id> <category>instance creation</category><body package="Values">newFor: targetClass	| inst |	inst := self new.	inst initializeTarget: targetClass.	^inst</body></methods><methods><class-id>Printargument</class-id> <category>initialize-release</category><body package="Values">initializeName: nameString value: valuePrintvalue	name := nameString.	value := valuePrintvalue.	self beImmutable</body></methods><methods><class-id>Printargument</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'name' value: self name).	args add: (printer constant: 'value' value: self value).	^printer printvalue: self arguments: args</body></methods><methods><class-id>Printargument</class-id> <category>accessing</category><body package="Values">name	"&lt;String&gt;"	^name</body><body package="Values">sourceWith: emitter	emitter emitArgument: self</body><body package="Values">value	"&lt;Printvalue&gt;"	^value</body></methods><methods><class-id>Printargument</class-id> <category>testing</category><body package="Values">isSimple	^self value isSimple</body></methods><methods><class-id>Printargument class</class-id> <category>instance creation</category><body package="Values">name: nameString value: valuePrintvalue	| inst |	inst := self new.	inst initializeName: nameString value: valuePrintvalue.	^inst</body></methods><methods><class-id>SourceEmitter</class-id> <category>accessing</category><body package="Values">emitterClassFor: printvalue	^printvalue isLine		ifTrue: [LineEmitter]		ifFalse: [BlockEmitter]</body><body package="Values">streamClass	^WriteStream</body></methods><methods><class-id>ValuePrintvalue</class-id> <category>accessing</category><body package="Values">arguments	"&lt;Array&gt;"	^arguments ifNil: [#()]</body><body package="Values">classname	"&lt;String&gt;"	^classname</body><body package="Values">sourceWith: emitter	self arguments isEmpty ifTrue: [		^emitter emitEmpty: self].	emitter inBracketsDo: [		emitter emitClass: self classname.		self arguments do: [:arg |			emitter emitSeparator.			emitter emitArgument: arg]]</body></methods><methods><class-id>ValuePrintvalue</class-id> <category>initialize-release</category><body package="Values">initializeClassname: classnameString arguments: argumentsArray	classname := classnameString.	(argumentsArray notNil and: [	argumentsArray notEmpty]) ifTrue: [			arguments := (Array withAll: argumentsArray) beImmutable].	self beImmutable</body></methods><methods><class-id>ValuePrintvalue</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'classname' value: self classname).	args add: (printer array: 'arguments' value: self arguments).	^printer printvalue: self arguments: args</body></methods><methods><class-id>ValuePrintvalue</class-id> <category>testing</category><body package="Values">isLine	self arguments size = 1 ifTrue: [		^self arguments first value isLine].	^self arguments size &lt; 5 and: [	self arguments allSatisfy: [:arg | arg isSimple]]</body></methods><methods><class-id>ValuePrintvalue class</class-id> <category>instance creation</category><body package="Values">classname: classnameString arguments: argumentsArray	| inst |	inst := self new.	inst initializeClassname: classnameString arguments: argumentsArray.	^inst</body></methods><methods><class-id>ValuePrintvalue class</class-id> <category>instance creation optional</category><body package="Values">classname: classnameString	^self classname: classnameString arguments: nil</body></methods><methods><class-id>LineEmitter</class-id> <category>writing</category><body package="Values">emitSeparator	self stream space</body></methods><methods><class-id>ArrayPrintvalue</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer array: 'arguments' value: self arguments).	^printer printvalue: self arguments: args</body></methods><methods><class-id>ArrayPrintvalue</class-id> <category>accessing</category><body package="Values">arguments	"&lt;Array&gt;"	^arguments ifNil: [#()]</body><body package="Values">sourceWith: emitter	emitter emitArraySourceFor: self arguments</body></methods><methods><class-id>ArrayPrintvalue</class-id> <category>testing</category><body package="Values">isLine	^self arguments size = 1 or: [	self arguments size &lt; 5 and: [	self arguments allSatisfy: [:arg | arg isSimple]]]</body></methods><methods><class-id>ArrayPrintvalue</class-id> <category>initialize-release</category><body package="Values">initializeArguments: argumentsArray	(argumentsArray notNil and: [	argumentsArray notEmpty]) ifTrue: [			arguments := (Array withAll: argumentsArray) beImmutable].	self beImmutable</body></methods><methods><class-id>ArrayPrintvalue class</class-id> <category>instance creation</category><body package="Values">arguments: argumentsArray	| inst |	inst := self new.	inst initializeArguments: argumentsArray.	^inst</body></methods><methods><class-id>BlockEmitter</class-id> <category>initialize-release</category><body package="Values">initializePrinter: aPrinter stream: aWriteStream level: anInteger	printer := aPrinter.	stream := aWriteStream.	level := anInteger + 1</body></methods><methods><class-id>BlockEmitter</class-id> <category>writing</category><body package="Values">emitSeparator	self stream cr.	self level + 1 timesRepeat: [self stream tab]</body></methods><methods><class-id>LiteralPrintvalue</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| args |	args := OrderedCollection new.	args add: (printer constant: 'string' value: self string).	^printer printvalue: self arguments: args</body></methods><methods><class-id>LiteralPrintvalue</class-id> <category>accessing</category><body package="Values">sourceWith: emitter	emitter emitValue: self string</body><body package="Values">string	"&lt;String&gt;"	^string</body></methods><methods><class-id>LiteralPrintvalue</class-id> <category>testing</category><body package="Values">isLine	^true</body><body package="Values">isSimple	^(self string first = $() not</body></methods><methods><class-id>LiteralPrintvalue</class-id> <category>initialize-release</category><body package="Values">initializeString: stringString	string := stringString.	self beImmutable</body></methods><methods><class-id>LiteralPrintvalue class</class-id> <category>instance creation</category><body package="Values">string: stringString	| inst |	inst := self new.	inst initializeString: stringString.	^inst</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>enumerating</category><body package="Values">asArgumentsIn: aBlock	"Evaluate aBlock with the receiver's elements as parameters.	aBlock takes its arguments from the receiver.	'ok'	#(1 2 3) asArgumentsIn: [:a :b :c | a + b + c]	#(1 2 3) asArgumentsIn: [:a :b | a + b]	#(1 2 3) asArgumentsIn: [:a | a]	#(1 2 3) asArgumentsIn: [42]	'not ok'	#(1 2 3) asArgumentsIn: [:a :b :c :d | a + b + c + d]	"	^aBlock cullWithArguments: self asArray</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>printing</category><body package="Values">printvalueWith: printer	self isLiteral ifTrue: [		^LiteralPrintvalue string: self storeString].	^ArrayPrintvalue arguments: (self collect: [:item | item printvalueWith: printer])</body></methods><methods><class-id>Core.Date class</class-id> <category>instance creation</category><body package="Values">d: dayInteger m: monthInteger y: yearInteger	^self newDay: dayInteger monthNumber: monthInteger year: yearInteger</body></methods><methods><class-id>Core.Date</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| wst |	wst := WriteStream on: (String new: 25).	wst		nextPut: $(;		nextPutAll: (printer classnameOf: self);		nextPutAll: ' d: ';		nextPutAll: self dayOfMonth printString;		nextPutAll: ' m: ';		nextPutAll: self monthIndex printString;		nextPutAll: ' y: ';		nextPutAll: self year printString;		nextPut: $).	^LiteralPrintvalue string: wst contents</body></methods><methods><class-id>Core.Object class</class-id> <category>named values</category><body package="Values">namedValueNames	"&lt;Array of: Symbol&gt;	names to print for special known values"		^#()</body><body package="Values">nameOrNilFor: aValue	"&lt;Symbol | nil&gt;"	^self namesByValues at: aValue ifAbsent: [nil]</body><body package="Values">namesByValues	"&lt;Dictionary key: Value value: Symbol&gt;"	^Value namedValuesAt: self ifAbsentPut: [self newNamesByValues]</body><body package="Values">newNamesByValues	"&lt;Dictionary key: Value value: Symbol&gt;"	| dict |	dict := Valuemap new: self namedValueNames size.	self namedValueNames do: [:symbol | dict at: (self perform: symbol) put: symbol].	^dict</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Values">asDescription	"&lt;Text&gt;	produces a text equivalent to the soure with bold leaf values"	^self asDescriptionFor: self class</body><body package="Values">asDescriptionFor: targetClass	"&lt;Text&gt;	produces a text equivalent to the source"	| printer printvalue |	printer := ValuePrinter newFor: targetClass.	printvalue := self printvalueWith: printer.	^printvalue description</body><body package="Values">asSource	"&lt;String&gt;	produces a string which can be evaluated in the context of the receiver class to an object equivalent to the receiver"	^self asSourceFor: self class</body><body package="Values">asSourceFor: targetClass	"&lt;String&gt;	produces a string which can be evaluated in the context of targetClass to an object equivalent to the receiver"	| printer printvalue |	printer := ValuePrinter newFor: targetClass.	printvalue := self printvalueWith: printer.	^printvalue sourceWithPrinter: printer</body></methods><methods><class-id>Core.Object</class-id> <category>comparing</category><body package="Values">isEqualValue: anObject	^self = anObject</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Values">printvalueWith: printer	^LiteralPrintvalue string: self storeString</body></methods><methods><class-id>Graphics.ColorValue class</class-id> <category>instance creation</category><body package="Values">fromByte: anInteger	^self fromBytes: (ByteArray new: 3 withAll: anInteger)</body><body package="Values">fromBytes: threeBytes	^self fromBytesRed: threeBytes first green: (threeBytes at: 2) blue: threeBytes last</body><body package="Values">fromBytesRed: redByte green: greenByte blue: blueByte	| scale |	scale := ColorValue scalingValue.	^ColorValue		scaledRed: redByte * scale // 255		scaledGreen: greenByte * scale // 255		scaledBlue: blueByte * scale // 255</body></methods><methods><class-id>Graphics.ColorValue class</class-id> <category>named values</category><body package="Values">namedValueNames	"The selection is the common set of color names with identical colors in VW and Squeak/Pharo	The colors are all variations of min and max of the 3 components"	"self namesByValues"		^#(#black #white	#red #green #blue	#cyan #magenta #yellow)</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>converting</category><body package="Values">asByteArray	^ByteArray		with: (self scaledRed bitShift: -5)		with: (self scaledGreen bitShift: -5)		with: (self scaledBlue bitShift: -5)</body><body package="Values">asGrayValue	"&lt;Number&gt;	between 0.0 (Black) and 1.0 (White) suitable for PDF DeviceGray"	^self brightness</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>testing</category><body package="Values">isEmpty	^self scaledRed isNil and: [	self scaledGreen isNil and: [	self scaledBlue isNil]]</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| args |	(self class nameOrNilFor: self) ifNotNil: [:symbol |		^LiteralPrintvalue string: (printer classnameOf: self) , ' ' , symbol asString].	args := OrderedCollection new.	args add: (printer constant: 'fromBytesRed' value: (self red * 255) rounded).	args add: (printer constant: 'green' value: (self green * 255) rounded).	args add: (printer constant: 'blue' value: (self blue * 255) rounded).	^printer printvalue: self arguments: args</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>converting</category><body package="Values">rgbIndex	"&lt;Integer&gt;	Three 8 bit RGB numbers interpreted as number for ordering"	^self asByteArray inject: 0 into: [:num :byte | (num bitShift: 8) + byte]</body></methods><methods><class-id>Core.Timestamp class</class-id> <category>instance creation</category><body package="Values">d: dayInteger m: monthInteger y: yearInteger	^self d: dayInteger m: monthInteger y: yearInteger h: 0 m: 0 s: 0</body><body package="Values">d: dayInteger m: monthInteger y: yearInteger h: hoursInteger	^self d: dayInteger m: monthInteger y: yearInteger h: hoursInteger m: 0 s: 0</body><body package="Values">d: dayInteger m: monthInteger y: yearInteger h: hoursInteger m: minutesInteger	^self d: dayInteger m: monthInteger y: yearInteger h: hoursInteger m: minutesInteger s: 0</body><body package="Values">d: dayInteger m: monthInteger y: yearInteger h: hoursInteger m: minutesInteger s: secondsInteger	| date time |	date := Date d: dayInteger m: monthInteger y: yearInteger.	time := Time h: hoursInteger m: minutesInteger s: secondsInteger.	^self fromDate: date andTime: time</body></methods><methods><class-id>Core.Timestamp</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| wst |	wst := WriteStream on: (String new: 50).	wst		nextPut: $(;		nextPutAll: (printer classnameOf: self);		nextPutAll: ' d: ';		nextPutAll: self dayOfMonth printString;		nextPutAll: ' m: ';		nextPutAll: self month printString;		nextPutAll: ' y: ';		nextPutAll: self year printString.	(self hour isZero and: [	self minute isZero and: [	self second isZero]]) ifTrue: [			wst nextPut: $).			^LiteralPrintvalue string: wst contents].	wst		nextPutAll: ' h: ';		nextPutAll: self hour printString.	(self minute isZero and: [	self second isZero]) ifTrue: [			wst nextPut: $).			^LiteralPrintvalue string: wst contents].	wst		nextPutAll: ' m: ';		nextPutAll: self minute printString.	self second isZero ifTrue: [		wst nextPut: $).		^LiteralPrintvalue string: wst contents].	wst		nextPutAll: ' s: ';		nextPutAll: self second printString;		nextPut: $).	^LiteralPrintvalue string: wst contents</body></methods><methods><class-id>Core.Time class</class-id> <category>instance creation</category><body package="Values">h: hoursInteger	^self h: hoursInteger m: 0 s: 0</body><body package="Values">h: hoursInteger m: minutesInteger	^self h: hoursInteger m: minutesInteger s: 0</body><body package="Values">h: hoursInteger m: minutesInteger s: secondsInteger	| inst |	inst := self new.	inst hours: hoursInteger minutes: minutesInteger seconds: secondsInteger.	^inst</body><body package="Values">zero	^self h: 0</body></methods><methods><class-id>Core.Time</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| wst |	wst := WriteStream on: (String new: 25).	(self hours isZero and: [	self minutes isZero and: [	self seconds isZero]]) ifTrue: [			wst				nextPutAll: (printer classnameOf: self);				nextPutAll: ' zero'.			^LiteralPrintvalue string: wst contents].	wst		nextPut: $(;		nextPutAll: (printer classnameOf: self);		nextPutAll: ' h: ';		nextPutAll: self hours printString.	(self minutes isZero and: [	self seconds isZero]) ifTrue: [			wst nextPut: $).			^LiteralPrintvalue string: wst contents].	wst		nextPutAll: ' m: ';		nextPutAll: self minutes printString.	self seconds isZero ifTrue: [		wst nextPut: $).		^LiteralPrintvalue string: wst contents].	wst		nextPutAll: ' s: ';		nextPutAll: self seconds printString;		nextPut: $).	^LiteralPrintvalue string: wst contents</body></methods><methods><class-id>Core.Dictionary</class-id> <category>dictionary testing</category><body package="Values">isEqualValue: anObject	^self contentsEquals: anObject</body></methods><methods><class-id>Core.Dictionary</class-id> <category>printing</category><body package="Values">keysForPrinting	^[self keys asSortedCollection] on: Error do: [:ex | ex return: self keys]</body><body package="Values">printargumentsWith: aPrinter	^self keysForPrinting collect: [:key |		DictionaryPrintargument			name: (key printvalueWith: aPrinter)			value: ((self at: key) printvalueWith: aPrinter)]</body><body package="Values">printvalueWith: printer	^DictionaryPrintvalue arguments: (self printargumentsWith: printer)</body></methods><methods><class-id>Core.Duration class</class-id> <category>instance creation</category><body package="Values">nanoseconds: aNumber	^aNumber nanoseconds</body></methods><methods><class-id>Core.Duration</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| wst |	wst := WriteStream on: (String new: 25).	wst		nextPut: $(;		nextPutAll: (printer classnameOf: self);		nextPutAll: ' nanoseconds: ';		nextPutAll: self asNanoseconds printString;		nextPut: $).	^LiteralPrintvalue string: wst contents</body></methods><methods><class-id>Kernel.GeneralBindingReference</class-id> <category>testing</category><body package="Values">isEqualValue: aQualifiedName	^self class == aQualifiedName class and: [	path = aQualifiedName path]</body></methods><methods><class-id>Core.Point</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| string |	string := (self x asSourceFor: printer target) , ' @ ' , (self y asSourceFor: printer target).	^LiteralPrintvalue string: string</body></methods><methods><class-id>Core.Class</class-id> <category>testing</category><body package="Values">isInScope: aClass	"&lt;Boolean&gt;	true if aClass is visible by the receiver - aClass can be used in the source without namespace qualifier.	false when aClass cannot be seen by the receiver - use the fullName"	| variableDefinition |	variableDefinition := (NameScope forClass: self) variableAt: aClass name from: nil.	^variableDefinition notNil and: [	variableDefinition binding value == aClass]</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="Values">nameRelativeTo: targetClass	"&lt;String&gt;"	"self nameRelativeTo: Object"	| ref |	(targetClass isInScope: self) ifTrue: [		^self name asString].	ref := self fullyQualifiedReference.	ref environmentName ifNil: [ref := self fullyQualifiedReferenceFrom: Root].	^ref asString</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>printing</category><body package="Values">printvalueWith: printer	| wst |	wst := WriteStream on: (String new: 25).	wst		nextPut: $(;		nextPutAll: (self origin asSourceFor: printer target);		nextPutAll: ' corner: ';		nextPutAll: (self corner asSourceFor: printer target);		nextPut: $).	^LiteralPrintvalue string: wst contents</body></methods><methods><class-id>Value class</class-id> <category>pragmas</category><body package="Values">specificationPragmas	&lt;pragmas: #class&gt;	^#(		#constant:class:		#constant:class:comment:				#optional:class:default:		#optional:class:default:comment:				#sequence:		#sequence:comment:		"#sequence:elements:comment:"				#map:		#map:comment:		"#map:keys:values:comment:"	)</body></methods><methods><class-id>DictionaryPrintvalue class</class-id> <category>specification</category><body package="Values">localSpecification	&lt;sequence: #arguments&gt;	&lt;optional: #isOrdered class: #{Boolean} default: 'false'&gt;</body></methods><methods><class-id>Printargument class</class-id> <category>specification</category><body package="Values">localSpecification	&lt;constant: #name class: #{String}&gt;	&lt;constant: #value class: #{Printvalue}&gt;</body></methods><methods><class-id>DictionaryPrintargument class</class-id> <category>specification</category><body package="Values">localSpecification	&lt;constant: #name class: #{Printvalue}&gt;	&lt;constant: #value class: #{Printvalue}&gt;</body></methods><methods><class-id>ValuePrintvalue class</class-id> <category>specification</category><body package="Values">localSpecification	&lt;constant: #classname class: #{String}&gt;	&lt;sequence: #arguments&gt;</body></methods><methods><class-id>ArrayPrintvalue class</class-id> <category>specification</category><body package="Values">localSpecification	&lt;sequence: #arguments&gt;</body></methods><methods><class-id>LiteralPrintvalue class</class-id> <category>specification</category><body package="Values">localSpecification	&lt;constant: #string class: #{String}&gt;</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Rectangle</name><environment>Graphics</environment><super>Graphics.Geometric</super><private>false</private><indexed-type>none</indexed-type><inst-vars>origin corner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>Duration</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>period scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Core</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Point</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>GeneralBindingReference</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>ColorValue</name><environment>Graphics</environment><super>Graphics.SimplePaint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>red green blue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class></st-source>